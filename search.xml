<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端开发面试题整理]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTML5CSS3flex/gridtranslate: matrix的几个参数垂直居中写一个 css3 动画，一个正方形线性下移50px盒模型，bfcfloat，position，清除浮动请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？JavascriptsessionId tokenwebsocket和长轮询ES6箭头函数promise写原生操作setCookie，getCookieJavaScript原型，原型链 ? 有什么特点？Javascript如何实现继承？ 构造函数继承，非构造函数继承Javascript作用链域什么是闭包（closure），为什么要用它call() 和 .apply() 的含义和区别？实现一个bindamd，cmd规范用户页面打开很慢，有哪些优化方式？webpack打包？ 讲了一下打包过程，loader，和plugin如何起作用的hybrid App，能讲一下原生和webview之间如何进行通信的么？websocket协议，以及nodejs中有哪些模块实现了这个协议this的描述和绑定规则new的过程中发生了什么（ES5，ES6）hashmap讲一下数据结构串、栈、队列、链表、哈希表、树、图js如何实现一个栈。哈希表是怎样的结构？说说操作系统的内存管理怎么实现一个服务器。浏览器是如何渲染页面的。进程与线程区别进程通信方式红黑树讲一下，五个特性，插入删除操作,时间复杂度二叉树转换成中序链表，不能用额外空间，可以递归。计算机网络http2比http1有什么优势HTTP状态码TCP 和 UDPdns 的查询过程OSI七层模型安全问题XSSCSRF浏览器劫持优化问题缓存机制Web优化的瓶颈是什么缓存中有last-modified规则了，为什么还要有etag。面试官告诉我是这样一种情况：当一个文件被加了一个空格，l-m就被修改了，然后再把那个空格删掉，此时文件还是原来那个文件，但l-m就不一样了，所以这就是etag的作用。 框架相关MVVM 和 MVCvue与jQuery的对比setter和gettervue的响应式原理：数据劫持 观察者模式，以及vue的组件化理解mvvm和mvp模式的简单描述vuex的作用，使用，以及个人的理解jQuery里使用$.attr(‘class’)方法，那么原生对应的是什么obj.classList。面试官告诉我的 十大排序算法其他跨域PWAGraghQLWebAssembly如果要做到服务器的推送，有哪些实现手段你是如何学习前端的？说下前端开发流程。说下怎么设计接口。前端开发一般要干什么。主要就是注意下三点：安全、性能优化、浏览器兼容。 讲下常见web攻击简短说了下:xss、csrf、dos、sql注入、点击劫持等等 面试官：那你还做后台实习？为什么不做后台开发呢？就讲了下自己当时打算以后做全栈工程师，就随便找了份实习，工作时候才发现好多东西要学，java后台已经发展得很成熟，spring框架等东西比较多，而我刚出来什么都不懂，每天都在学框架的东西，记那些配置，只是为了应付工作，没有深入地了解框架如何实现，所以让我学的很不爽，不能掌控的感觉。我想要的是那种从底层就比较了解的感觉，目前前端让我学的很舒服，会去看jquery、vue等框架如何实现的，最近也在看《你不知道的javascript》深入地学习js，本来以为自己学的差不多了，后来发现了还有挺多要学的。 你大学学的课程和前端有关联吗？就把操作系统、编译原理和浏览器运行机制、js引擎等扯了下。把计算机网络相关的和前端优化、前后端交互等扯了下。把应用密码学和WEB安全等扯了下。把数据结构和算法、算法设计与分析等和其他的也扯了下。当然图形学、软件测试、数据库、软件工程、系统设计与分析等等都是可以帮助前端开发与学习的。 输入url的过程中发生了什么反转一个字符串以及优化说出什么是AVL（二叉反转树）反转链表]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝node-记一次vue结合axios参数提交问题]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%B5%85%E5%B0%9Dnode-%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E7%BB%93%E5%90%88axios%E5%8F%82%E6%95%B0%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面闲来无事，最近使用vue全家桶结合nodejs搭建了一个简单的网站，在前端使用的axios做请求，后端框架使用express框架，在前端做数据请求时，因为axios默认的使用multipart/form-data编码方式进行参数提交，一般默认来说，post请求不涉及到文件上传一般都是使用的x-www-form-urlencoded编码方式进行参数提交，然后…噩梦开始了…（ps:觉得比较啰嗦的可直接看结论,哈哈\^_\^） 问题还原因为axios默认使用multipart/form-data编码方式，因此我们需要在请求头中添加一行代码：1&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 此时在服务器端接收参数时，发现使用req.body无法获取参数（默认已经使用中间件解析参数）：12app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); 百度后发现，需要使用qs中间件将axios 请求参数序列化，也就是使用如下代码：123if (config.method === &apos;post&apos;) &#123; config.data = qs.stringify(config.data) &#125; 现在服务器端能够正常的接收到数据，并且存入数据库，本以为这样就完了…（补充一句：如果上传的vey/value，value值不是对象，而是单个的string或者number等，服务器端是可以正常接收到参数，也就是说可以使用req.body.key取到数据的。只有是对象，数组等类型，默认也是字符串，并且key/value都是字符串，因此想使用req.body.key是不行的）因结构需要，有两个参数需上传对象，并且存入数据库中，首先，前端上传参数如图1所示：刚开始测试的时候使用的apizza插件进行服务器端调试，发现上传参数没问题（并未做存入数据库处理），后使用前后端联调方式进行，发现前端上传的数据格式如图2所示：我们可以看到，此时links是单引号，当时并未想到是字符串，因为第一次使用axios，也为后面的踩坑埋下伏笔…通过观察存入数据库中的数据发现，links字段并未存入数据库，因为前面使用插件调通的，因此并未多想，monoose数据模型如图3所示： 分析原因开始以为是存入对象需要将模型中的links字段更改为Miexd类型数据，但是发现没用，然后花了两天时间，查各种文档，一直将问题定位在了数据库存储类型上….结果今天早上起床后继续调试，终于发现哪里不对，图2的links字段，好像有个单引号，突然反应过来，这不就是字符串吗？立马对比插件和axios发出去的请求，发现插件请求可以获取到，而axios请求却获取不到？忽然想起来，前端有一句: 需要使用qs中间件将axios 请求参数序列化结果看代码是：1qs.stringify(config.data) 这个和1JSON.stringify() 何其相识~~~与之对应的肯定需要:1qs.parse() 结果在服务器端加入了这样一段代码后:1var req = qs.parse(req.body); 就能正常解析上传的参数。。。自此问题解决。。。。 结论在使用axios进行请求时候请注意以下几点：1.axios默认使用的编码方式为：multipart/form-data，如需使用x-www-form-urlencoded编码方式，请使用qs中间件将参数序列化。（如不序列化，服务器端无法获取到上传的参数）2.服务器端我是采用的nodejs，此时需要将qs序列化后的参数反序列化，将其转化为JSON格式。 ##后记俗话说，有得必有失。。。虽然调BUG调的有待难受，但是，收获也很多… 造成这次BUG有多方面原因：1.自己不熟悉axios框架。2.较粗心，一直未曾发觉上传的参数是字符串。3.mongoose使用的不熟悉（一直以为是数据库存储的原因，数据模型建立的有问题。。。） 收获：1.通过这个BUG，重新翻阅了mongoose的相关操作，对mongoose理解加深。2.重新翻阅了http相关的知识点，了解简单的http请求头的信息，以及基本原理。3.重新了解了一遍axios的API请求，进一步熟悉axios的请求。 ps:以上内容仅为自己的学习过程，欢迎大家取其精华，丢其糟粕。若对以上内容有不同简介或看法，欢迎一起探讨。企鹅号：1041415167 邮箱地址：zth1041415167@outlook.com]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝MUI-记一次沉浸式问题]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%B5%85%E5%B0%9DMUI-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B2%89%E6%B5%B8%E5%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面最近有一个页面需要使用MUI的可左右拖动的顶部选项卡框架，但是这个框架需要自己设定高度，因此使用的JS来动态计算，在计算过程中发现一个问题，使用浏览器测试时（真机，浏览器同苹果6测试），通过图1可以看出，计算出的框架高度应该是100px，但是在真机运行时，控制台打印出来的高度却是，120px，ps：(因为有底部导航栏51px，采用的原生方案，因此压缩了webview页面高度，所以看到的页面高度为616px。) 分析过程进一步分析，计算出图3部分的高度： 通过图4，图5,可看到打印出来的高度值： 通过上图可以看出，这部分的元素没有影响我们的高度获取，那么继续进一步排查，再往上走就只有header标签（图6），但是这部分高度我们是给的固定值44px，不管怎么说，打印出来试试： 通过图7 图8可以发现，真机运行和浏览器运行居然不一样！ 此时，恍然大悟! 结论因为设置了沉浸式状态栏，所以通过获取状态栏高度，自动调整了header标签的高度（ps：给了一个paddingtop；padding在使用offsetHeight计算高度时，会计算进去）。因此我们多出来16px的高度，导致页面出现纵向滚动条。进一步猜测：设置了沉浸式后，状态栏就像是absolute属性一样，浮动在上方。因此，小伙伴们一定要注意这个问题！（ps：查了好久，一直以为是offsetTop属性不会获取padding的值，顺带跑去复习了一遍offset的用法。。。结果查出来是状态栏原因。）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--详解im-chat源码]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E8%AF%A6%E8%A7%A3im-chat%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面因最近项目需要制作一个聊天界面，对比后感觉MUI源码内的im-chat.html文件对各种情况的处理比较的全面，因此，将整个页面的逻辑从头到尾理了一遍，希望有需求的小伙伴可以少走弯路，通过这个模板，可以根据我们自己需要的功能进行定制，如果不是很清楚（用词不当）的地方，还请小伙伴们提出来，做相关修改，谢谢！ps：理这种逻辑性的东西需要耐心，所以希望小伙伴能够静下心来慢慢理，任何代码都是根据需求实现。所以，可以结合实际操作来看相关模块。最后，求一波关注，哈哈！ 相关引用这个聊天框架基于MUI开发，正常引入相关文件后，还需引入如下文件： 图片预览的mui.imageviewer.css样式文件， 处理图片浏览的mui.imageViewer.js文件， 模板渲染的arttmpl.js文件；代码详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448&lt;body contextmenu=&quot;return false;&quot;&gt; &lt;header class=&quot;mui-bar mui-bar-nav&quot;&gt; &lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; &lt;h1 class=&quot;mui-title&quot;&gt;chat (聊天窗口)&lt;/h1&gt; &lt;/header&gt; &lt;pre id=&apos;h&apos;&gt;&lt;/pre&gt; &lt;script id=&apos;msg-template&apos; type=&quot;text/template&quot;&gt; &lt;% for(var i in record)&#123; var item=record[i]; %&gt; &lt;div class=&quot;msg-item &lt;%= (item.sender==&apos;self&apos;?&apos; msg-item-self&apos;:&apos;&apos;) %&gt;&quot; msg-type=&apos;&lt;%=(item.type)%&gt;&apos; msg-content=&apos;&lt;%=(item.content)%&gt;&apos;&gt; &lt;% if(item.sender==&apos;self&apos; ) &#123; %&gt; &lt;i class=&quot;msg-user mui-icon mui-icon-person&quot;&gt;&lt;/i&gt; &lt;% &#125; else &#123; %&gt; &lt;img class=&quot;msg-user-img&quot; src=&quot;../images/logo.png&quot; alt=&quot;&quot; /&gt; &lt;% &#125; %&gt; &lt;div class=&quot;msg-content&quot;&gt; &lt;div class=&quot;msg-content-inner&quot;&gt; &lt;% if(item.type==&apos;text&apos; ) &#123; %&gt; &lt;%=( item.content|| &apos;&amp;nbsp;&amp;nbsp;&apos;) %&gt; &lt;% &#125; else if(item.type==&apos;image&apos; ) &#123; %&gt; &lt;img class=&quot;msg-content-image&quot; src=&quot;&lt;%=(item.content)%&gt;&quot; style=&quot;max-width: 100px;&quot; /&gt; &lt;% &#125; else if(item.type==&apos;sound&apos; ) &#123; %&gt; &lt;span class=&quot;mui-icon mui-icon-mic&quot; style=&quot;font-size: 18px;font-weight: bold;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;play-state&quot;&gt;点击播放&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;msg-content-arrow&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mui-item-clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/script&gt; &lt;div class=&quot;mui-content&quot;&gt; &lt;div id=&apos;msg-list&apos;&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer&gt; &lt;div class=&quot;footer-left&quot;&gt; &lt;i id=&apos;msg-image&apos; class=&quot;mui-icon mui-icon-camera&quot; style=&quot;font-size: 28px;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;footer-center&quot;&gt; &lt;textarea id=&apos;msg-text&apos; type=&quot;text&quot; class=&apos;input-text&apos;&gt;&lt;/textarea&gt; &lt;button id=&apos;msg-sound&apos; type=&quot;button&quot; class=&apos;input-sound&apos; style=&quot;display: none;&quot;&gt;按住说话&lt;/button&gt; &lt;/div&gt; &lt;label for=&quot;&quot; class=&quot;footer-right&quot;&gt; &lt;i id=&apos;msg-type&apos; class=&quot;mui-icon mui-icon-mic&quot;&gt;&lt;/i&gt; &lt;/label&gt; &lt;/footer&gt; &lt;div id=&apos;sound-alert&apos; class=&quot;rprogress&quot;&gt; &lt;div class=&quot;rschedule&quot;&gt;&lt;/div&gt; &lt;div class=&quot;r-sigh&quot;&gt;!&lt;/div&gt; &lt;div id=&quot;audio_tips&quot; class=&quot;rsalert&quot;&gt;手指上滑，取消发送&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/mui.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/mui.imageViewer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/arttmpl.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; (function($, doc) &#123; var MIN_SOUND_TIME = 800; $.init(&#123; gestureConfig: &#123; tap: true, //默认为true doubletap: true, //默认为false longtap: true, //默认为false swipe: true, //默认为true drag: true, //默认为true hold: true, //默认为false，不监听 release: true //默认为false，不监听 &#125; &#125;); template.config(&apos;escape&apos;, false); //$.plusReady=function(fn)&#123;fn();&#125;; $.plusReady(function() &#123; plus.webview.currentWebview().setStyle(&#123; softinputMode: &quot;adjustResize&quot; &#125;); //强制弹出键盘 var showKeyboard = function() &#123; if ($.os.ios) &#123; var webView = plus.webview.currentWebview().nativeInstanceObject(); webView.plusCallMethod(&#123; &quot;setKeyboardDisplayRequiresUserAction&quot;: false &#125;); &#125; else &#123; var Context = plus.android.importClass(&quot;android.content.Context&quot;); var InputMethodManager = plus.android.importClass(&quot;android.view.inputmethod.InputMethodManager&quot;); var main = plus.android.runtimeMainActivity(); var imm = main.getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED); //var view = ((ViewGroup)main.findViewById(android.R.id.content)).getChildAt(0); imm.showSoftInput(main.getWindow().getDecorView(), InputMethodManager.SHOW_IMPLICIT); //alert(&quot;ll&quot;); &#125; &#125;; var record = [&#123; sender: &apos;zs&apos;, type: &apos;text&apos;, content: &apos;Hi，我是 MUI 小管家！&apos; &#125;]; var ui = &#123; body: doc.querySelector(&apos;body&apos;), footer: doc.querySelector(&apos;footer&apos;), footerRight: doc.querySelector(&apos;.footer-right&apos;), footerLeft: doc.querySelector(&apos;.footer-left&apos;), btnMsgType: doc.querySelector(&apos;#msg-type&apos;), boxMsgText: doc.querySelector(&apos;#msg-text&apos;), boxMsgSound: doc.querySelector(&apos;#msg-sound&apos;), btnMsgImage: doc.querySelector(&apos;#msg-image&apos;), areaMsgList: doc.querySelector(&apos;#msg-list&apos;), boxSoundAlert: doc.querySelector(&apos;#sound-alert&apos;), h: doc.querySelector(&apos;#h&apos;), content: doc.querySelector(&apos;.mui-content&apos;) &#125;; //将文本框宽度赋值给h ui.h.style.width = ui.boxMsgText.offsetWidth + &apos;px&apos;; //alert(ui.boxMsgText.offsetWidth ); //让文本框居中 var footerPadding = ui.footer.offsetHeight - ui.boxMsgText.offsetHeight; //语音输入相关操作 var msgItemTap = function(msgItem, event) &#123; var msgType = msgItem.getAttribute(&apos;msg-type&apos;); var msgContent = msgItem.getAttribute(&apos;msg-content&apos;) if (msgType == &apos;sound&apos;) &#123; player = plus.audio.createPlayer(msgContent); var playState = msgItem.querySelector(&apos;.play-state&apos;); playState.innerText = &apos;正在播放...&apos;; player.play(function() &#123; playState.innerText = &apos;点击播放&apos;; &#125;, function(e) &#123; playState.innerText = &apos;点击播放&apos;; &#125;); &#125; &#125;; //图片预览组件 var imageViewer = new $.ImageViewer(&apos;.msg-content-image&apos;, &#123; dbl: false &#125;); //绑定消息节点 var bindMsgList = function() &#123; //绑定数据: /*tp.bind(&#123; template: &apos;msg-template&apos;, element: &apos;msg-list&apos;, model: record &#125;);*/ //将数据绑定到界面上 ui.areaMsgList.innerHTML = template(&apos;msg-template&apos;, &#123; &quot;record&quot;: record &#125;); //拿到所有的聊天节点 var msgItems = ui.areaMsgList.querySelectorAll(&apos;.msg-item&apos;); //因为document.querySelectorAll()返回的并不是我们想当然的数组，而是NodeList，对NodeList，它里面没有.forEach方法，我们使用了这样的方法进行循环： //通过call将this绑定到msgItems（以[]下标的方式去遍历msgItems） [].forEach.call(msgItems, function(item, index) &#123; item.addEventListener(&apos;tap&apos;, function(event) &#123; //处理语音消息播放 msgItemTap(item, event); &#125;, false); &#125;); //查找所有符合条件的图片 imageViewer.findAllImage(); //聊天界面的高度修改 ui.areaMsgList.scrollTop = ui.areaMsgList.scrollHeight + ui.areaMsgList.offsetHeight; &#125;; bindMsgList(); //平滑高度过渡 window.addEventListener(&apos;resize&apos;, function() &#123; ui.areaMsgList.scrollTop = ui.areaMsgList.scrollHeight + ui.areaMsgList.offsetHeight; &#125;, false); //发送对象声明 var send = function(msg) &#123; //将消息内容体push进record record.push(msg); //绑定消息节点 bindMsgList(); toRobot(msg.content); &#125;; var toRobot = function(info) &#123; var apiUrl = &apos;http://www.tuling123.com/openapi/api&apos;; $.getJSON(apiUrl, &#123; &quot;key&quot;: &apos;acfbca724ea1b5db96d2eef88ce677dc&apos;, &quot;info&quot;: info, &quot;userid&quot;: plus.device.uuid &#125;, function(data) &#123; //alert(JSON.stringify(data)); record.push(&#123; sender: &apos;zs&apos;, type: &apos;text&apos;, content: data.text &#125;); bindMsgList(); &#125;); &#125;; //让输入框获取焦点 function msgTextFocus() &#123; ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); &#125; //解决长按“发送”按钮，导致键盘关闭的问题； ui.footerRight.addEventListener(&apos;touchstart&apos;, function(event) &#123; if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; msgTextFocus(); event.preventDefault(); &#125; &#125;); //解决长按“发送”按钮，导致键盘关闭的问题； ui.footerRight.addEventListener(&apos;touchmove&apos;, function(event) &#123; if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; msgTextFocus(); event.preventDefault(); &#125; &#125;); // ui.footerRight.addEventListener(&apos;touchcancel&apos;, function(event) &#123; // if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; // msgTextFocus(); // event.preventDefault(); // &#125; // &#125;); // ui.footerRight.addEventListener(&apos;touchend&apos;, function(event) &#123; // if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; // msgTextFocus(); // event.preventDefault(); // &#125; // &#125;); //长按离开屏幕时触发 ui.footerRight.addEventListener(&apos;release&apos;, function(event) &#123; //当是文字时 if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; //showKeyboard(); ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); // event.detail.gesture.preventDefault(); send(&#123; sender: &apos;self&apos;, type: &apos;text&apos;, content: ui.boxMsgText.value.replace(new RegExp(&apos;\n&apos;, &apos;gm&apos;), &apos;&lt;br/&gt;&apos;) &#125;); ui.boxMsgText.value = &apos;&apos;; $.trigger(ui.boxMsgText, &apos;input&apos;, null); &#125; //当是语音时 else if (ui.btnMsgType.classList.contains(&apos;mui-icon-mic&apos;)) &#123; ui.btnMsgType.classList.add(&apos;mui-icon-compose&apos;); ui.btnMsgType.classList.remove(&apos;mui-icon-mic&apos;); ui.boxMsgText.style.display = &apos;none&apos;; ui.boxMsgSound.style.display = &apos;block&apos;; ui.boxMsgText.blur(); document.body.focus(); &#125; //当是文本状态时 else if (ui.btnMsgType.classList.contains(&apos;mui-icon-compose&apos;)) &#123; ui.btnMsgType.classList.add(&apos;mui-icon-mic&apos;); ui.btnMsgType.classList.remove(&apos;mui-icon-compose&apos;); ui.boxMsgSound.style.display = &apos;none&apos;; ui.boxMsgText.style.display = &apos;block&apos;; //-- //showKeyboard(); ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); &#125; &#125;, false); //点击左边按钮时 ui.footerLeft.addEventListener(&apos;tap&apos;, function(event) &#123; var btnArray = [&#123; title: &quot;拍照&quot; &#125;, &#123; title: &quot;从相册选择&quot; &#125;]; plus.nativeUI.actionSheet(&#123; title: &quot;选择照片&quot;, cancel: &quot;取消&quot;, buttons: btnArray &#125;, function(e) &#123; var index = e.index; switch (index) &#123; case 0: break; case 1: var cmr = plus.camera.getCamera(); cmr.captureImage(function(path) &#123; send(&#123; sender: &apos;self&apos;, type: &apos;image&apos;, content: &quot;file://&quot; + plus.io.convertLocalFileSystemURL(path) &#125;); &#125;, function(err) &#123;&#125;); break; case 2: plus.gallery.pick(function(path) &#123; send(&#123; sender: &apos;self&apos;, type: &apos;image&apos;, content: path &#125;); &#125;, function(err) &#123;&#125;, null); break; &#125; &#125;); &#125;, false); //控制按住语音时的显示与隐藏 var setSoundAlertVisable=function(show)&#123; if(show)&#123; ui.boxSoundAlert.style.display = &apos;block&apos;; ui.boxSoundAlert.style.opacity = 1; &#125;else&#123; ui.boxSoundAlert.style.opacity = 0; //fadeOut 完成再真正隐藏 setTimeout(function()&#123; ui.boxSoundAlert.style.display = &apos;none&apos;; &#125;,200); &#125; &#125;; var recordCancel = false; var recorder = null; var audio_tips = document.getElementById(&quot;audio_tips&quot;); var startTimestamp = null; var stopTimestamp = null; var stopTimer = null; //按住说话时候触发 ui.boxMsgSound.addEventListener(&apos;hold&apos;, function(event) &#123; recordCancel = false; //如果有结束时间，清除定时器 if(stopTimer)clearTimeout(stopTimer); //修改显示文字 audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; //移除rprogress-sigh ui.boxSoundAlert.classList.remove(&apos;rprogress-sigh&apos;); //显示样式 setSoundAlertVisable(true); //获取录音对象 5+模块 recorder = plus.audio.getRecorder(); if (recorder == null) &#123; plus.nativeUI.toast(&quot;不能获取录音对象&quot;); return; &#125; //记录当前录音时间 startTimestamp = (new Date()).getTime(); //保存录音http://www.html5plus.org/doc/zh_cn/audio.html#plus.audio.RecordOption recorder.record(&#123; filename: &quot;_doc/audio/&quot; &#125;, function(path) &#123; if (recordCancel) return; send(&#123; sender: &apos;self&apos;, type: &apos;sound&apos;, content: path &#125;); &#125;, function(e) &#123; plus.nativeUI.toast(&quot;录音时出现异常: &quot; + e.message); &#125;); &#125;, false); //监听drag（拖动中）事件 上滑;下滑事件 ui.body.addEventListener(&apos;drag&apos;, function(event) &#123; //console.log(&apos;drag&apos;); if (Math.abs(event.detail.deltaY) &gt; 50) &#123; //此时没有录音操作执行 检查recordCancel状态 if (!recordCancel) &#123; recordCancel = true; if (!audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.add(&quot;cancel&quot;); &#125; audio_tips.innerHTML = &quot;松开手指，取消发送&quot;; &#125; &#125; else &#123; if (recordCancel) &#123; recordCancel = false; if (audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.remove(&quot;cancel&quot;); &#125; audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; &#125; &#125; &#125;, false); //长按离开录音节点时执行 ui.boxMsgSound.addEventListener(&apos;release&apos;, function(event) &#123; //console.log(&apos;release&apos;); //初始化 if (audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.remove(&quot;cancel&quot;); audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; &#125; //判断录音是否小于800毫秒，若小于，则废弃 stopTimestamp = (new Date()).getTime(); if (stopTimestamp - startTimestamp &lt; MIN_SOUND_TIME) &#123; audio_tips.innerHTML = &quot;录音时间太短&quot;; ui.boxSoundAlert.classList.add(&apos;rprogress-sigh&apos;); recordCancel = true; stopTimer=setTimeout(function()&#123; setSoundAlertVisable(false); &#125;,800); &#125;else&#123; setSoundAlertVisable(false); &#125; //停止录音模块 recorder.stop(); &#125;, false); //阻止浏览器默认的事件冒泡 ui.boxMsgSound.addEventListener(&quot;touchstart&quot;, function(e) &#123; //console.log(&quot;start....&quot;); e.preventDefault(); &#125;); //监听用户输入时触发 ui.boxMsgText.addEventListener(&apos;input&apos;, function(event) &#123; //当输入为空时去掉发送文字，当不为空时，显示发送文字 ui.btnMsgType.classList[ui.boxMsgText.value == &apos;&apos; ? &apos;remove&apos; : &apos;add&apos;](&apos;mui-icon-paperplane&apos;); //当用户输入值不为空时，设置自定义属性for 赋值msg-text ui.btnMsgType.setAttribute(&quot;for&quot;, ui.boxMsgText.value == &apos;&apos; ? &apos;&apos; : &apos;msg-text&apos;); //替换与正则表达式相匹配的值(转义) ui.h.innerText = ui.boxMsgText.value.replace(new RegExp(&apos;\n&apos;, &apos;gm&apos;), &apos;\n-&apos;) || &apos;-&apos;; //动态调整输入框高度 ui.footer.style.height = (ui.h.offsetHeight + footerPadding) + &apos;px&apos;; //调整显示信息高度 ui.content.style.paddingBottom = ui.footer.style.height; &#125;); var focus = false; //监听用户点击发送时触发 ui.boxMsgText.addEventListener(&apos;tap&apos;, function(event) &#123; //得到焦点 ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 0); focus = true; setTimeout(function () &#123; focus = false; &#125;,1000); //阻止iOS2.0中的手势事件：gesture事件 event.detail.gesture.preventDefault(); &#125;, false); //点击消息列表，关闭键盘 ui.areaMsgList.addEventListener(&apos;click&apos;,function (event) &#123; if(!focus)&#123; ui.boxMsgText.blur(); &#125; &#125;) &#125;); &#125;(mui, document)); &lt;/script&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探prototype]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2prototype%2F</url>
    <content type="text"><![CDATA[// 构造函数/基类function Human(name){ this.name = name;}//将基类的方法保存在构造函数的prototype属性中//便于子类的继承Human.prototype.say=function(){ console.log(‘say’);} //道格拉斯的object方法(等同于object.create方法)function object(o){ var F = function(){}; F.prototype = o; return new F();} //子类构造器function Man(name,age){ //调用父类的构造函数 Human.call(this,name); //自己属性的age this.age = age;} //继承父类的方法 constructor 属性返回对创建此对象的数组函数的引用。Man.prototype = object(Human,prototype);Man.prototype.constructor = Man; //实例化子类var man = new Man(“Lee”, 22);console.log(man);//调用父类的say方法；man.say();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习笔记(一)]]></title>
    <url>%2F2017%2F10%2F19%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[学习笔记关于node.js1.node.js属于单线程，单进程应用程序，每个API都是异步进行，并作为独立线程运行。2.Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。3.Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.4.在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 理解：在主线程接收到请求等操作，便分出一个进程单独处理，而主进程依然按照以前的状态运行，这样，只需要一个单进程的单线程就处理高并发。（难道线程或进程开多了不会造成卡顿吗？），而事件驱动模型，类似于主进程在那里观察整个运作流程，而有进程处理完相关操作后，返回给主进程，然后主进程按照编程者所预设的流程执行下一步？ 关于Node.js EventEmitter1.Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。2.Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 1.EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 2.EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 理解：许多对象分发的事件都是EventEmitter的实例，也就是说，假如我们需要监听我们的事件是否执行，执行完毕，执行错误等，都可以通过监听这个EventEmitter 类来实现。不知是否用于添加自定义函数，可以监听函数的各种变化？暂不知道有什么用… 关于Node.js Buffer(缓冲区) Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。2.Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。理解：用来暂时存储流，元信息等？ 关于Node.js Stream(流)1.Node.js，Stream 有四种流类型： Readable - 可读操作。 ritable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。2.所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 理解：将文件等转化为二进制后慢慢写入或者读出来？管道流：实现大文件复制，文件不是一次发送过去，而像是流水一样慢慢流入，并且在流完后组合成大文件。 关于Node.js模块系统1.Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。2.模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 理解：模块系统，使不同模块，不同文件之间，实现信息共享，相互引用？ ！ 关于Node.js 函数1.在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。2.我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) { someFunction(value); } execute(function(word){ console.log(word) }, “Hello”); 理解：函数与在浏览器端使用相同，匿名函数，函数传递？ 关于Node.js 路由1.我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。2.我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 理解：将请求分发，重定位到服务器上不同的处理请求的函数中去？ 关于Node.js 全局对象1.JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。2.在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。3.在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。4.global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量；全局对象的属性；隐式定义的变量（未定义直接赋值的变量）。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。5.filename: 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。6.dirname: 表示当前执行脚本所在的目录。7.setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。8.clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。9.console 方法1 console.log([data][, …])向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。2 console.info([data][, …])该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。3 console.error([data][, …])输出错误消息的。控制台在出现错误时会显示是红色的叉子。4 console.warn([data][, …])输出警告消息。控制台出现有黄色的惊叹号。5 console.dir(obj[, options])用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。6 console.time(label)输出时间，表示计时开始。7 console.timeEnd(label)结束时间，表示计时结束。8 console.trace(message[, …])当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。9 console.assert(value[, message][, …])用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 10.console.trace()：向标准错误流输出当前的调用栈。 运行结果为：Trace:at Object. (/home/byvoid/consoletrace.js:1:71)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 11.process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。 1 exit当进程准备退出时触发。2 beforeExit当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。3 uncaughtException当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。4 Signal 事件当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 退出状态码如下所示： 1 Uncaught Fatal Exception有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。2 Unused保留3 Internal JavaScript Parse ErrorJavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。4 Internal JavaScript Evaluation FailureJavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。5 Fatal ErrorV8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR6 Non-function Internal Exception Handler未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。7 Internal Exception Handler Run-Time Failure未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。8 Unused保留9 Invalid Argument可能是给了未知的参数，或者给的参数没有值。10 Internal JavaScript Run-Time FailureJavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。12 Invalid Debug Argument设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。128 Signal Exits如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。 Process 提供了很多有用的属性，便于我们更好的控制系统的交互： 1 stdout标准输出流。2 stderr标准错误流。3 stdin标准输入流。4 argvargv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。5 execPath返回执行当前脚本的 Node 二进制文件的绝对路径。6 execArgv返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。7 env返回一个对象，成员为当前 shell 的环境变量8 exitCode进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。9 versionNode 的版本，比如v0.10.18。10 versions一个属性，包含了 node 的版本和依赖.11 config一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。12 pid当前进程的进程号。13 title进程名，默认值为”node”，可以自定义该值。14 arch当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。15 platform运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’16 mainModulerequire.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 Process 提供了很多有用的方法，便于我们更好的控制系统的交互： 1 abort()这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。2 chdir(directory)改变当前工作进程的目录，如果操作失败抛出异常。3 cwd()返回当前进程的工作目录4 exit([code])使用指定的 code 结束进程。如果忽略，将会使用 code 0。5 getgid()获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。6 setgid(id)设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。7 getuid()获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。8 setuid(id)设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。9 getgroups()返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。10 setgroups(groups)设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。11 initgroups(user, extra_group)读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。12 kill(pid[, signal])发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。13 memoryUsage()返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。14 nextTick(callback)一旦当前事件循环结束，调用回到函数。15 umask([mask])设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。16 uptime()返回 Node 已经运行的秒数。17 hrtime()返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 理解：一些常用的控制台输入输出函数，以全局形式存在，目前没有遇到过，也不是很懂具体用法，后期多关注这一模块。 关于Node.js 常用工具1.util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。2.util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。3.JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。 理解： 使用util.inherits只能继承原型链上的函数，并不能继承原型内申明的函数。 4.util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。 5.util.isArray(object)：如果给定的参数 “object” 是一个数组返回true，否则返回false。 6.util.isRegExp(object)： 如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。 7.util.isDate(object)： 如果给定的参数 “object” 是一个日期返回true，否则返回false。 8.util.isError(object)： 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。 理解：和浏览器端的JSON.stringify()等类似？ 关于Node.js 文件系统1.Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。2.Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 理解：用于读写文件内容等操作。 关于Node.js GET/POST请求1.在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。表单提交到服务器一般都使用 GET/POST 请求。 理解：post请求中，不会自动解析body内容，减少恶意POST占用服务器资源。 ###]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝MUI-HBuilder编译器]]></title>
    <url>%2F2017%2F10%2F19%2F%E6%B5%85%E5%B0%9DMUI-HBuilder%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[浅谈HBuilder编译器第一次接触HBuilder是通过老师介绍，这款编译器是中国的公司编写，因此，对于英语不是很好的小伙伴来说是很友好的。当然，这款编译器和MUI框架配套使用可以更加的方便，工欲善其事，必先利其器，所以，今天特地来讲一下HBuilder编译器。附HBuilder下载地址。下面就具体来讲讲HBuildder编译器的简单操作功能吧。ps：关于快捷方式，基本的编译器设置等，因为与我们使用和编写代码关系不大，因此，此处就不展开介绍，只讲与使用MUI相关的知识点。 Hbuilder简单使用HBuilder的组成：由项目管理器，控制台，代码编辑器区，内置浏览器，顶部导航条构成，如图2所示：ps：当我们看过整个内容区域后，讲下今天主要想写的知识点：1.开发视图区别；2.新建一个web项目；3.新建一个APP项目；4.查看MUI源码；5.真机运行；6.自定义调试基座；7.APP的云端打包。1.开发视图简单介绍：平常我们基本上都是用得边改边看模式，因为这个模式可以在代码编辑区编写代码保存后，在右边可以实时查看效果。而WebView调试模式一般用于真机测试时，调试页面（ps：后面详细介绍）。团队同步视图因为很少用，需要小伙伴们自己去开发了哟~~视图切换如图2所示：2.打开文件–&gt;新建–&gt;web项目，此时只需要填写项目名称和保存位置就OK，此时会生成一个项目在项目管理器中，在里面可以看到项目结构。 后记]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI(二)]]></title>
    <url>%2F2017%2F10%2F17%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[初探MUI(二)MUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 学习心得学习完MUI基础理论后，相信很多人都会觉得MUI真的很方便，基本需求都能够的到满足，但其实不然，因为MUI有很多的局限性，以及对某些手机的兼容性问题，导致很多时候会出现莫名其妙的BUG。根据个人观察发现，对于苹果系统更加的友好，而对于安卓系统，因为碎片化太严重，所以应该多找些机型测试。 我遇到过的情况有：1.底部导航栏（html5）：在红米note2，小米3，华为手机上完美使用，但是oppo一款型号底部导航条出现下移情况（注：底部导航条高度通过JS计算，高度写死时不会出现），如果遇到，将底部导航条高度写死。 2.华为手机的虚拟按键，如果按照正常的流式布局下去，当页面内容多于屏幕高度时，底部有fixed定位的元素时，虚拟按键可能会把底部定位的东西遮挡住。(ps:经过测试，华为虚拟按键会缩小屏幕实际高度）解决办法：因为虚拟按键会压缩屏幕高度，而页面底部距离底部定位时，可以将fixed定位的元素挤压上去，将body，html页面高度设置为100%。 3.使用&lt;header&gt;&lt;/header&gt;时，如果页面有&lt;input type=&#39;text /&gt;，此时输入文字会将&lt;header&gt;&lt;/header&gt;挤掉，我的解决办法是：打开软键盘时，挤压webview，减少视口的高度。但是这样做有一个问题，如果页面内容较多，会产生滚动条，给用户的感觉不好。也可以监听软键盘打开事件，动态调整页面。下面仅给出最简单的解决方案：12345mui.plusReady(function () &#123; plus.webview.currentWebview().setStyle(&#123; softinputMode: "adjustResize" &#125;);&#125;); 4.使用原生底部导航条，目前遇到的问题是，真机测试时，在苹果6上完美渲染，测试相关逻辑都成功，但是在红米note2上，有两个ICON渲染不出来，只渲染出来了底部导航栏的高度，具体情况尚在测试中。。。。 学习总结1.在调试MUI项目时，我认为应该先使用安卓手机调试，因为我几次都是在苹果手机上成功调试，但是将源码放到安卓手机上时，出现各种未知的BUG,所以前期测试使用安卓手机，等程序调试完成后，再去苹果手机上测试。 2.因为现在很多人都追求使用原生来写html5，在官方还没发布正式的底部导航条时，就自己按照社区的经验，自己改了一个底部导航条，但是因为打开新的页面时，底部原生导航条不会隐藏，所以没办法，还是只能采用mui提供的底部导航条，所以，对于mui的探索，还是需要自己去多研究，例如：和原生相关的界面渲染，操作原生的内容，调用原生JS等，都需要仔细的研究。所以，我觉得，如果有一定的安卓或者IOS开发经验的人来说比较的容易理解，但是对于一个前端开发人员来说，这一块肯定是学习的重点。 后记]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI%2F</url>
    <content type="text"><![CDATA[初探MUIMUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 浅谈MUI当然，学习一门东西之前肯定需要先了解他，知道这个东西是干什么的。简单的来说，MUI是一个轻量级的HTML5前端框架，用它可以写出轻量级的APP应用，但根据我自己探索出来的区间是:1.安卓手机：4.4以下卡顿比较明显（ps：极有可能是自身代码问题），安卓5.0能够流畅运行；2.苹果手机：测试机使用的苹果6，对于一般应用能够完美运行（ps：苹果5s仅测试过chrome）。（注:以上数据仅为自己测试，测试数据不一定准确。) 学习MUI无论是学习一门语言，还是学习一个框架，必然第一步是看官方文档，唯有熟悉官方文档后，才能谈使用。而我学习的步骤如下：1.全览MUI文档，对MUI框架有一个简单的认识，知道这个框架大概有哪些东西，一般用于什么情况，此为第一次浏览。2.熟悉文档后，打开Hbuilder，文件-&gt;新建-&gt;移动APP，在弹出框中选中Hello mui，并输入应用名称，此时会有一个项目出现在左侧栏，里面便是整个MUI框架的源码。 （注：为什么这步写的这么详细呢，因为我发现很多小伙伴用了几个月时间的Hbuilder居然不知道这个编译器还可以写手机APP，Hbuilder最初不是和MUI配套发布的吗？表示不理解~）3.拿到源码后，先看一遍整个demo，很多文档上面提到的东西，在源码里面都有体现，当然，我学到这一步时，脑袋里也只有一点最初的概念，这时，我觉得就没必要再去深究了。因为代码这种东西必须要多敲，所以，自己新建一个项目，模仿一个APP来写页面。那么，重点来了，各种复制粘贴MUI源码里面的东西来修改吧，建议调试使用（chrome浏览器）。4.或许有人不理解为什么要模仿，但是我感觉模仿是最简单，也是最节省精力的一种方法，因为不用考虑布局本身，只需要把框架内的东西复制粘贴出来，似拼图一般，搭建一个属于自己的第一个APP界面，当然，在这个过程中肯定会遇到很多的问题，我的建议是自己去网上找资料并且看代码。网上资料的话可以去MUI的问答社区，感觉这个社区已经足够解决大部分问题了，如果还有不能解决的问题，那么我感觉大部分原因在自身（1.忘记引入相关文件 2.以往设置相关模块的JS代码），这个时候就需要更多的耐心查看代码相关逻辑了。 后记只要反复练习上面的第四点，我相信对MUI框架和HTML5在手机端的布局就会有一个明确的认识，这个时候再去浏览一遍官方文档和demo肯定会有新的收获。毕竟身为程序员，逃不掉的始终是敲代码，唯有多练习，才能更加熟悉，唯有动手了，才能知道自己哪些知识点还不足，从而更加针对性的去补足。上面的内容，虽然对代码只字未提，但是我想无论是编程语言还是框架等都只是一个工具，在学习时，更多的是找到自己学习的节奏和方法，编程时，更多的是思路和想法。以上内容仅为自己的学习过程，欢迎大家取其精华，丢其糟粕，找到自己的学习状态。若对以上内容有不同简介或看法，欢迎一起探讨。企鹅号：1041415167 邮箱地址：zth1041415167@outlook.com 附部分学习资料地址： forked from dcloudio DCloud开源项目集锦 问答社区 forked from 小青年 github MUI框架视频教程地址 （ps：第一次写这个，写的不好还请多多见谅！终于领悟一个道理，知道容易，想要很好的说出来真的好难^-^ ^-^ 以上内容可能会不定期修改更新，下一篇日记准备列出关于MUI在学习MUI时遇到的各种坑，希望新学的小伙伴不要再去踩，也希望有兴趣的小伙伴多多关注！）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
</search>
