<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端开发面试题整理]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTML5CSS3flex/grid任何一个容器都可以指定为Flex布局，设置 display:flex;设置这个属性之后，子元素的float,clear和vertical-align属性将会失效。 圣杯布局flex代码：123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&quot;container&quot;&gt; &lt;header&gt;Header&lt;/header&gt; &lt;div class=&quot;content&quot;&gt; &lt;main&gt;Main&lt;/main&gt; &lt;nav&gt;Nav&lt;/nav&gt; &lt;aside&gt;Aside&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;Footer&lt;/footer&gt;&lt;/div&gt;&lt;style&gt;.container&#123; display:flex; /* 垂直*/ flex-direction: column; width:100%; /*视口被均分为100单位的vh 占据整个窗口*/ min-height:100vh;&#125;header,footer&#123; /*放大缩小比例为0 占据垂直方向80px*/ flex:0 0 80px;&#125;.content&#123; display: flex; /*1 1 auto 后两个值省略*/ flex:1;&#125;nav&#123; /*默认 0 数值越小 排列越靠前*/ order:-1; flex:0 0 80px;&#125;aside&#123; flex:0 0 80px;&#125;main&#123; flex:1;&#125;&lt;/style&gt; 圣杯布局grid代码:1234567891011121314151617181920212223242526272829303132333435&lt;section class=&quot;grid&quot;&gt; &lt;div class=&quot;title&quot;&gt;title&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;nav&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/section&gt;.grid &#123; display: grid; width: 100vw; height: 100vh; grid-template-columns: 80px 1fr 1fr 1fr 80px; grid-template-rows: 80px 1fr 1fr 80px; grid-template-areas: &apos;title title title title title&apos; &apos;nav main main main aside&apos; &apos;nav main main main aside&apos; &apos;footer footer footer footer footer&apos;; font-size: 30px; text-align: center;&#125;.title &#123; grid-area: title;&#125;.nav &#123; grid-area: nav;&#125;.main &#123; grid-area: main;&#125;.aside &#123; grid-area: aside;&#125;.footer &#123; grid-area: footer;&#125; translate: matrix的几个参数12345678偏移transform: matrix(1, 0, 0, 1, 30, 30)就等同于transform: translate(30px, 30px)缩放transform: matrix(2, 0, 0, 3, 0, 0)就等同于transform: scale(2, 3)旋转transform: matrix(0.866025,0.500000,-0.500000,0.866025,0,0)就等同于transform:rotate(30deg)倾斜matrix(1, 2.237161, 2.237161,1,0,0)就等同于transform:skew(20deg,20deg) 总结 matrix(a,b,c,d,e,f) 1.偏移：e、f参数决定 2.缩放：a、d参数决定 3.旋转：matrix(cosθ,sinθ,-sinθ,cosθ,0,0) 4.倾斜：b、c参数决定 垂直居中1.flex实现垂直居中 display：flex；align-self：center；2.display：inline-block；vertical-align：middle；3.父元素添加伪元素：before123456#out:before&#123; content:&apos;&apos;; display:inline-block; vertical-align:middle; height:100%;&#125; 4.table-cell #out:{display:table}; #in:{display:table-cell;vertical-align:middle};5.隐藏节点123456789101112#hide&#123; width:25%; height:25%; //隐藏节点的height为剩余高度的一半&#125;#in&#123; width:50%; height:50%;&#125;&lt;div id=&quot;out&quot;&gt; &lt;div id=&quot;hide&quot;&gt;&lt;/div&gt; &lt;div id=&quot;in&quot;&gt;&lt;/div&gt;&lt;/div&gt; 6.通过transform已知父元素高度子元素代码123position:relative;top:50%;transform:translateY(-50%); 7.line-height实现垂直居中123456#out&#123; height:300px;&#125;#in&#123; line-height:300px;&#125; 写一个 css3 动画，一个正方形线性下移50px123456789101112131415161718192021#out&#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/&#125;@keyframes mymove&#123;from &#123;top:0px;&#125;to &#123;top:50px;&#125;&#125;@-webkit-keyframes mymove /*Safari and Chrome*/&#123;from &#123;top:0px;&#125;to &#123;top:50px;&#125;&#125;&lt;div id=&quot;out&quot;&gt;&lt;/div&gt; 盒模型，bfc完整整理答案：https://segmentfault.com/a/1190000013069516盒子默认为标准盒模型。专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： （1）基本概念：content、padding、margin。 （2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。 1. IE盒模型：width = content+padding+margin+border; 2. 标准盒模型：width = content； （3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 1. box-sizing: content-box; 2. box-sizing: border-box; （4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 1. dom.style.width/height(只适用获取内联元素的宽和高) 2. dom.currentStyle.width/height(获取渲染后的宽高，但是仅IE支持) 3. window.getComputedStyle(dom).width/height(与2原理相似，但是兼容性，通用性会更好一些) 4. dom.getBoundingClientRect().widht/height(计算元素绝对位置，获取到四个元素left,top,width,height) （5）实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 （6）BFC（边距重叠解决方案）或IFC。盒子模型的范围包括 margin、border、padding、content,且content部分不包含其他部分IE盒子模型content部分包括了border和padding12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; BFC（边距重叠解决方案）BFC的概念BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理/BFC的布局规则【非常重要】BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： （1）BFC 里面的元素，在垂直方向，边距会发生重叠。 （2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） （3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） （4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC有以下几种方法： 方法1：overflow: 不为vidible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex 为什么父元素成为BFC之后，就有了高度呢？计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算。 BFC 的应用举例1：解决 margin 重叠当父元素和子元素发生 margin 重叠时，解决办法：给子元素增加一个父元素，给这个父元素创建BFC。举例2：BFC区域不与float区域重叠：可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性）举例3：清除浮动:方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可 float，position，清除浮动清除浮动： clear：both； clearfix:before,.clearfix:after{display:table;content:”“;}.clearfix:after{clear:both;}.clearfix{*zoom:1}等行内元素： 设置width，height无效； 设置margin，只有左右有效，上下无效； 设置padding，只有top无效；JavascriptsessionId token1、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。websocket和长轮询1.轮询轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的有用数据可能只是一个很小的值，这样会占用很多的带宽。2.长轮询:ajax实现:在发送ajax后,服务器端会阻塞请求直到有数据传递或超时才返回。 客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。3.Web Socket:轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是”在服务器端数据有了变化后，可以主动推送给客户端”,这种”主动型”服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。ES6箭头函数头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略。promise写原生操作setCookie，getCookie1234567891011121314151617181920212223function setCookie()&#123; var never = new Date(); //设置never的时间为当前时间加上十年的毫秒值 never.setTime(never.getTime()+10*365*24*60*60*1000); var expString = &quot;expires=&quot;+ never.toGMTString()+&quot;;&quot;; document.cookie = &quot;area=&quot;+escape(&quot;北京海淀&quot;)+&quot;;&quot;+expString; document.cookie = &quot;zipcode=100080;&quot;; &#125; function getCookie(name)&#123; var result = null; //对cookie信息进行相应的处理，方便搜索 var myCookie = &quot;&quot;+document.cookie+&quot;;&quot;; var searchName = &quot;+name+&quot;=&quot;; var startOfCookie =myCookie.indexOf(searchName); var endOfCookie; if(satrtOfCookie != -1)&#123; startOfcookie += searchName.length; endOfCookie= myCookie.indexOf(&quot;;&quot;,startOfCookie); result = (myCookie.substring(startOfCookie,endOfCookie)); &#125; return result;&#125; JavaScript原型，原型链 ? 有什么特点？ JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。 每个继承父函数的子函数的对象都包含一个内部属性proto。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的proto属性为再上一层函数。在此过程中就形成了原型链。 原型链实现了继承。原型链存在两个问题：a 包含引用类型值的原型属性会被所有实例共享。b 在创建子类型时，无法向超类型的构造函数中传递参数。 Javascript如何实现继承？ 构造函数继承，非构造函数继承ps: https://blog.csdn.net/qq_31280709/article/details/52137086 Javascript作用链域ps: https://segmentfault.com/a/1190000007841345 什么是闭包（closure），为什么要用它闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收 call() 和 .apply() 的含义和区别？ 首先说明两个方法的含义： apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。call 与 apply 的相同点： 方法的含义是一样的，即方法功能是一样的；第一个参数的作用是一样的；call 与 apply 的不同点：两者传入的列表形式不一样 call可以传入多个参数；apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入存在的意义：实现（多重）继承 实现一个bindps: https://www.cnblogs.com/heshan1992/p/6667596.html amd，cmd规范ps: https://www.jianshu.com/p/5eb49f5c5196 用户页面打开很慢，有哪些优化方式？ps: https://www.cnblogs.com/xp796/p/5236945.html webpack打包？ 讲了一下打包过程，loader，和plugin如何起作用的webpack打包过程，ps: https://www.cnblogs.com/yxy99/p/5852987.html webpack中loader和plugin这两个概念很容易为初学者混淆，在这里，我简单谈谈自己的理解。 对于loader，它就是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程； 对于plugin，它就是一个扩展器，它丰富了wepack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，例如 run：开始编译make：从entry开始递归分析依赖并对依赖进行buildbuild-moodule：使用loader加载文件并build模块normal-module-loader：对loader加载的文件用acorn编译，生成抽象语法树ASTprogram：开始对AST进行遍历，当遇到require时触发call require事件seal：所有依赖build完成，开始对chunk进行优化（抽取公共模块、加hash等）optimize-chunk-assets：压缩代码emit：把各个chunk输出到结果文件通过对节点的监听，从而找到合适的节点对文件做适当的处理。 hybrid App，能讲一下原生和webview之间如何进行通信的么？ps: https://blog.csdn.net/xiaoqiang_0719/article/details/52383920 websocket协议，以及nodejs中有哪些模块实现了这个协议 websocket协议：ps：https://www.cnblogs.com/fuqiang88/p/5956363.html Nodejs实现websocket的4种方式：socket.io、WebSocket-Node、faye-websocket-node、node-websocket-server，主要使用的是socket.iothis的描述和绑定规则ps: https://www.cnblogs.com/xiaohuochai/p/5735901.htmlnew的过程中发生了什么（ES5，ES6）new 的过程实际上分三步。1，创建一个以这个函数为原型的空对象.2，将函数的 prototype 赋值给对象的 proto 属性3，将对象作为函数的 this 传进去。如果有 return 出来东西是对象的话就直接返回 return 的内容，没有的话就返回创建的这个对象代码实现如下：123456789101112function NewFunc(func)&#123; var ret = &#123;&#125;; if (func.prototype !== null) &#123; ret.__proto__ = func.prototype; &#125; var ret1 = func.apply(ret, Array.prototype.slice.call(arguments, 1)); if ((typeof ret1 === &quot;object&quot; || typeof ret1 === &quot;function&quot;) &amp;&amp; ret1 !== null) &#123; return ret1; &#125; return ret;&#125; hashmap讲一下js实现hashmap ps:http://www.cnblogs.com/jcjssl/p/9371425.html 数据结构串、栈、队列、链表、哈希表、树、图js如何实现一个栈。ps: https://www.cnblogs.com/liangsongbai/p/5875681.html 哈希表是怎样的结构？哈希表的存储结构为散列函数。散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。这里把这种对应关系f称为散列函数，又称为哈希（Hash）函数。按这个思想，采用散列技术将记录存在在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。那么，关键字对应的记录存储位置称为散列地址。散列技术最适合的求解问题是查找与给定值相等的记录。对于查找来说，简化了比较过程，效率会大大 提高。但是，散列技术部具备很多常规数据结构的能力，如比较同样的关键字，对应很多记录的情况，不适合用散列技术；散列表也不适合范围查找等等。在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。市场会碰到两个关键字key1 != key2，但是却有f(key1) = f(key2)，这种现象称为冲突。出现冲突将会造成查找错误，因此可以通过精心设计散列函数让冲突尽可能的少，但是不能完全避免。 说说操作系统的内存管理ps: https://www.cnblogs.com/niupan369/p/4076738.html 怎么实现一个服务器。浏览器是如何渲染页面的。浏览器的渲染页面时，表示网站资源已经请求成功。渲染时，大致的流程如下：（解析html以构建dom树-&gt;构建render树-&gt;布局render树-&gt;绘制render树）具体的流程如下：1：浏览器会将HTML解析成一个DOM树，DOM树的构建过程是一个深度遍历过程，当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点，2：将CSS解析成CSS规则树；3：根据DOM树和CSS来构造render树，渲染树不等于DOM树，像header和display：none；这种没有具体内容的东西就不在渲染树中；4：根据render树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系，然后可以计算出每个节点在屏幕中的位置；5：遍历render树进行绘制页面中的各元素。P.S页面发生重拍（回流）的话，会重新加载DOM树，影响页面加载速度。会导致页面重拍的原因如下：1：页面初始化；2：操作DOM时；3：某些元素的尺寸变了；4：CSS的属性发生改变。浏览器加载页面资源的步骤如下（部分参考网络资料）：1.用户输入网址（假设是第一次访问），浏览器向服务器发出请求，服务器返回html文件；2.浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；3.浏览器又发出CSS文件的请求，服务器返回这个CSS文件；4.浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了；5.浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续加载后面的代码；6.服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；7.浏览器发现了一个包含一行Javascript代码的＜script＞标签，直接运行该脚本；8.Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。少了一个元素，浏览器不得不重新渲染这部分代码；9.＜/html＞表示暂时加载完成；10.此时用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；11.浏览器向服务器请求了新的CSS文件，重新加载页面。然后执行渲染过程。 进程与线程区别简言之：进程就是一个应用程序在处理机上的一次执行过程，它是一个动态的概念，而线程是进程中的一部分，进程包含多个线程在运行。线程是指进程内的一个执行单元,也是进程内的可调度实体.与进程的区别:(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;(2)资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源(3)线程是处理器调度的基本单位,但进程不是.4)二者均可并发执行.进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。 进程和线程的区别在于： 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 进程通信方式ps: https://blog.csdn.net/wh_sjc/article/details/70283843 红黑树讲一下，五个特性，插入删除操作,时间复杂度ps: https://blog.csdn.net/u011240877/article/details/53329023 二叉树转换成中序链表，不能用额外空间，可以递归。ps: https://blog.csdn.net/my_heart_/article/details/52730649 计算机网络http2比http1有什么优势1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。 大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别 2.HTTP2支持多路复用 因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求 3.HTTP2头部压缩 HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了 4.HTTP2支持服务器推送 HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容 HTTP状态码2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 TCP 和 UDPps: https://blog.csdn.net/li_ning_/article/details/52117463 dns 的查询过程DNS查询过程 假设www.abc.com的主机要查询www.xyz.abc.com的服务器ip地址。 知识点 1、hosts文件：以静态映射的方式提供IP地址与主机名的对照表，类似ARP表 2、域：abc.com是一个域，它可以划分为多个区域，如abc.com和xyz.abc.com 步骤 递归查询 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找 第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的DNS服务器查询 第四步：‘根DNS服务器’根据查询域名中的‘xyz.com’，再向xyz.com的区域服务器查询 第五步：www.xyz.abc.com的DNS服务器直接解析该域名，将查询到的ip再原路返回给请求查询的主机 迭代查询 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 第二步：上一步无法找到，在DNS本地服务器（即域服务器）查找所有本层次的区域服务器 第三步：本地DNS服务器查不到就查询上一层次的所有区域服务器，以此类推直至根域名DNS服务器‘.’ 第四步：到达根域名服务器后又向下查询，直至查到结果为止。 迭代查询与递归查询结合 递归查询需要经过逐层查询才能获得查询结果，当查询具有许多层次的DNS结构时效率很低，所以一般采用两者相结合的查询方式。 第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址 第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找 第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的根DNS服务器查询 第四步：根DNS服务器直接将其区域DNS服务器的ip地址返回给本地服务器，而不用再向xyz.com的区域服务器查询。 第五步：本地DNS服务器将结果返回给请求的主机 OSI七层模型ps: https://www.cnblogs.com/jeanschen/p/3762475.html 安全问题XSSXSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。ps: https://blog.csdn.net/u011781521/article/details/53894399/ CSRFPs: https://www.cnblogs.com/wangyuyu/p/3388169.html 浏览器劫持常见的浏览器劫持有：篡改主页、修改快捷方式、随浏览器启动、利用WMI插件修改 篡改主页：该情况多出现在安装完流氓软件，在安装过程中申请修改了主页。国内很多软件都有这样的特点，请大家在安装软件的时候，不要急于点击下一步，要确定每一步的操作后再点击下一步。 修改快捷方式：这种情况是篡改主页的升级版。解决方法是：在浏览器图标右键-&gt;属性，第二栏快捷方式，去除目标里的网址即可解决。但这种情况往往治标不治本，如果在修改后电脑又出现这种情况，则说明有在开机后运行的软件检测了浏览器的快捷方式并重新修改了，需要通过监视进程来找出是什么软件造成的（在此推荐火绒安全软件），并卸载该软件，即可永久解决该问题。 随浏览器启动：这个情况在当时我遇到的时候检查了好久我的电脑环境（诸如注册表、浏览器属性等等），最后才发现是因为电脑后台的程序在监听浏览器，每次打开浏览器的时候都会自动跳转到那个网页。解决方法也很简单：检查后台随开机启动的软件（我的是因为使用了净网大师），查看是否有选择性推广，取消掉就好了。 利用WMI插件修改：这种情况较少见，但还是存在的。WMI是Windows的一个插件，可以运行脚本，所以利用WMI插件来劫持的原理是：在WMI中写入一个定时脚本，隔一定的时间就主动检测浏览器是否为脚本设定好的主页，如果不是则篡改，如果是则脚本结束。该脚本可以通过手动删除，也可以通过安全软件来清理（在此推荐火绒安全软件） 无论浏览器劫持会怎样发展，都希望各位读者可以保持一个良好的上网习惯。 优化问题缓存机制浏览器缓存：Ps：https://www.cnblogs.com/slly/p/6732749.html Web优化的瓶颈是什么web优化：https://www.cnblogs.com/liulilin/p/7245125.html优化瓶颈：瓶颈是什么。 一条4车道的公路，运行非常顺畅，突然出了点事故，事故车导致某个地方只剩下1车道，然后就开始堵车，因为四辆车同时塞向一个车道里。把这个事故清除了，故障车拖走了，道路会开始恢复了通畅。 这个道理谁都懂，但偏偏有些傻瓜交警去把4车道变成8车道，但却不清理事故路段。 一个Web应用，不管是何种语言开发，粗略的结构无非是三层： 页面模板 可以是JSP、ASP、PHP等页面技术，根据数据生成最终的HTML页面，性能关键指标只有一个，页面的渲染速度。综合各种页面技术而言，渲染速度相差不会太大，10倍以内。 业务逻辑 用于根据业务需要将数据库中的数据读取到内存中，以便通过页面模板渲染成HTML页面。这里面可能还包括缓存、连接池等技术。 数据库 就是数据库，负责执行SQL查询并返回查询结果。 我们假设用户访问一个页面，也就是请求一个URL地址，然后得到内容，所需要的时间是3秒钟。其中大部分时间可能用在网络传输上，而真正页面执行并生成HTML内容所需的时间是很小的，这里假设需要100毫秒。 相当于用户花了两秒多钟在传输数据上，这部分时间如果能缩减，可以大大提升访问的速度，但是这部分一般也难以提升了，因为取决于用户本身的网络情况，服务器的网络情况以及中间整个路由的情况。对于一个网站来说，能做的就是尽可能的提升服务器的带宽，或者使用CDN来减少中间路由环节，很不幸的是，这个成本很高。 好吧，前面提到的更多是非技术因素，假设你已经耗费巨资解决了这个问题，然后突然发现网络太快了，可是服务器顶不住了，生成一个页面居然要100毫秒，才几十个并发用户就差点要把服务器搞崩溃了。 于是来到了本文的重点部分——找出应用的性能瓶颈。 前面我们提到的结构中的三层：页面模板，业务逻辑和数据库，根据经验值，在这100毫秒中，三个部分占用的时间差不多为：页面模板(5%)、业务逻辑+数据库(95%)。 几个准则： 没必要去优化页面模板，这都是一些很成熟的技术，就算你好不容易提升了10%的性能，这10%在整个页面的执行过程中只占了0.5%的比例，微乎其微，等于是前面例子中的4车道变8车道的傻瓜，我们不要去充当傻瓜。 一般瓶颈所在以及相应处理办法 数据库连接：使用连接池来减少连接次数 重复的数据库查询：使用缓存来避免重复的数据库查询 慢查询：使用索引来提升查询速度，使用连接查询替换子查询等 简简单单的三条，里面却包含了很深的功夫，特别是在数据库查询优化上。 你必须在充分解决了这些应用程序所属的性能瓶颈之后，再去考虑系统级别的优化。 一些常用系统级别优化包括： 静态文件和动态页面分开处理 应用服务器的集群 数据库的集群 不要本末倒置，一个性能很差的应用程序，你就算集群了100个节点，也不会有什么效果。 所以Web网站优化三部曲：应用程序优化、系统结构优化、网络优化。 缓存中有last-modified规则了，为什么还要有etag。面试官告诉我是这样一种情况：当一个文件被加了一个空格，l-m就被修改了，然后再把那个空格删掉，此时文件还是原来那个文件，但l-m就不一样了，所以这就是etag的作用。Ps:If-Modified-Since：作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中. ETag：是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。 ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。 问题是，我们知道last-modified可以用来判断浏览器的本地缓存是否有效，那为什么还要使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。 框架相关MVVM 和 MVCps: https://www.cnblogs.com/junhuawang/p/5211892.html vue与jQuery的对比Ps: https://www.cnblogs.com/MR-YY/p/6898464.html setter和getterPs: https://www.cnblogs.com/lvmylife/p/8327961.html vue的响应式原理：数据劫持 观察者模式，以及vue的组件化理解Ps: vue组件化理解：https://www.jianshu.com/p/ce97328a9085 vuex的作用，使用，以及个人的理解Ps：https://blog.csdn.net/weixin_36593033/article/details/78327252 jQuery里使用$.attr(‘class’)方法，那么原生对应的是什么obj.classList.面试官告诉我的 十大排序算法Ps: https://www.cnblogs.com/onepixel/articles/7674659.html 其他跨域Ps: https://www.cnblogs.com/2050/p/3191744.html PWAPs: https://segmentfault.com/a/1190000012353473 GraghQLPs: https://segmentfault.com/a/1190000014131950 WebAssemblyPs: https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html 如果要做到服务器的推送，有哪些实现手段你是如何学习前端的？说下前端开发流程。Ps: https://blog.csdn.net/xtaydwxf1988/article/details/75043753 说下怎么设计接口。Ps: https://www.cnblogs.com/accident/p/8872204.html 前端开发一般要干什么。主要就是注意下三点：安全、性能优化、浏览器兼容。 讲下常见web攻击简短说了下:xss、csrf、dos、sql注入、点击劫持等等 面试官：那你还做后台实习？为什么不做后台开发呢？就讲了下自己当时打算以后做全栈工程师，就随便找了份实习，工作时候才发现好多东西要学，java后台已经发展得很成熟，spring框架等东西比较多，而我刚出来什么都不懂，每天都在学框架的东西，记那些配置，只是为了应付工作，没有深入地了解框架如何实现，所以让我学的很不爽，不能掌控的感觉。我想要的是那种从底层就比较了解的感觉，目前前端让我学的很舒服，会去看jquery、vue等框架如何实现的，最近也在看《你不知道的javascript》深入地学习js，本来以为自己学的差不多了，后来发现了还有挺多要学的。 你大学学的课程和前端有关联吗？就把操作系统、编译原理和浏览器运行机制、js引擎等扯了下。把计算机网络相关的和前端优化、前后端交互等扯了下。把应用密码学和WEB安全等扯了下。把数据结构和算法、算法设计与分析等和其他的也扯了下。当然图形学、软件测试、数据库、软件工程、系统设计与分析等等都是可以帮助前端开发与学习的。 输入url的过程中发生了什么Ps: https://www.cnblogs.com/zgx123/p/7379993.html 反转一个字符串以及优化Ps: https://www.cnblogs.com/JohnTsai/p/5606719.html 说出什么是AVL（二叉反转树）Ps: https://blog.csdn.net/pointer_y/article/details/53011343 反转链表js实现反转链表：https://blog.csdn.net/HaiJing1995/article/details/72809346 完整信息ps: https://github.com/BearD01001/front-end-QA-to-interview#new操作符具体干了什么呢 2018.08.29 腾讯面试 ‘64’+‘4’的值 正则表达式 new RegExp(‘/s’,’g’); 正则表达式 /^\d{1,2}\D\d{1,2}\D\d{1,2}\D/可以匹配什么 表格合并 哪些用到了哈希表（sha-1，md5） 鼠标移入，鼠标移出。鼠标事件，键盘事件监听，form表单监听，若一个fn返回true则提交，返回false则阻止提交（阻止事件冒泡） bind与闭包的关系，闭包与作用域链的关系 使用随机数n 查找出不重复的[2， 32]范围内的数字。 bind方法继承至哪里 当this指向全局的时候，考虑严格模式！ this与闭包的关系。 一个字符串查询第一个唯一出现的字母 http的三次握手 四次挥手]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>面试笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝node-记一次vue结合axios参数提交问题]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%B5%85%E5%B0%9Dnode-%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E7%BB%93%E5%90%88axios%E5%8F%82%E6%95%B0%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面闲来无事，最近使用vue全家桶结合nodejs搭建了一个简单的网站，在前端使用的axios做请求，后端框架使用express框架，在前端做数据请求时，因为axios默认的使用multipart/form-data编码方式进行参数提交，一般默认来说，post请求不涉及到文件上传一般都是使用的x-www-form-urlencoded编码方式进行参数提交，然后…噩梦开始了…（ps:觉得比较啰嗦的可直接看结论,哈哈\^_\^） 问题还原因为axios默认使用multipart/form-data编码方式，因此我们需要在请求头中添加一行代码：1&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 此时在服务器端接收参数时，发现使用req.body无法获取参数（默认已经使用中间件解析参数）：12app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); 百度后发现，需要使用qs中间件将axios 请求参数序列化，也就是使用如下代码：123if (config.method === &apos;post&apos;) &#123; config.data = qs.stringify(config.data) &#125; 现在服务器端能够正常的接收到数据，并且存入数据库，本以为这样就完了…（补充一句：如果上传的vey/value，value值不是对象，而是单个的string或者number等，服务器端是可以正常接收到参数，也就是说可以使用req.body.key取到数据的。只有是对象，数组等类型，默认也是字符串，并且key/value都是字符串，因此想使用req.body.key是不行的）因结构需要，有两个参数需上传对象，并且存入数据库中，首先，前端上传参数如图1所示：刚开始测试的时候使用的apizza插件进行服务器端调试，发现上传参数没问题（并未做存入数据库处理），后使用前后端联调方式进行，发现前端上传的数据格式如图2所示：我们可以看到，此时links是单引号，当时并未想到是字符串，因为第一次使用axios，也为后面的踩坑埋下伏笔…通过观察存入数据库中的数据发现，links字段并未存入数据库，因为前面使用插件调通的，因此并未多想，monoose数据模型如图3所示： 分析原因开始以为是存入对象需要将模型中的links字段更改为Miexd类型数据，但是发现没用，然后花了两天时间，查各种文档，一直将问题定位在了数据库存储类型上….结果今天早上起床后继续调试，终于发现哪里不对，图2的links字段，好像有个单引号，突然反应过来，这不就是字符串吗？立马对比插件和axios发出去的请求，发现插件请求可以获取到，而axios请求却获取不到？忽然想起来，前端有一句: 需要使用qs中间件将axios 请求参数序列化结果看代码是：1qs.stringify(config.data) 这个和1JSON.stringify() 何其相识~~~与之对应的肯定需要:1qs.parse() 结果在服务器端加入了这样一段代码后:1var req = qs.parse(req.body); 就能正常解析上传的参数。。。自此问题解决。。。。 结论在使用axios进行请求时候请注意以下几点：1.axios默认使用的编码方式为：multipart/form-data，如需使用x-www-form-urlencoded编码方式，请使用qs中间件将参数序列化。（如不序列化，服务器端无法获取到上传的参数）2.服务器端我是采用的nodejs，此时需要将qs序列化后的参数反序列化，将其转化为JSON格式。 ##后记俗话说，有得必有失。。。虽然调BUG调的有待难受，但是，收获也很多… 造成这次BUG有多方面原因：1.自己不熟悉axios框架。2.较粗心，一直未曾发觉上传的参数是字符串。3.mongoose使用的不熟悉（一直以为是数据库存储的原因，数据模型建立的有问题。。。） 收获：1.通过这个BUG，重新翻阅了mongoose的相关操作，对mongoose理解加深。2.重新翻阅了http相关的知识点，了解简单的http请求头的信息，以及基本原理。3.重新了解了一遍axios的API请求，进一步熟悉axios的请求。 ps:以上内容仅为自己的学习过程，欢迎大家取其精华，丢其糟粕。若对以上内容有不同简介或看法，欢迎一起探讨。企鹅号：1041415167 邮箱地址：zth1041415167@outlook.com]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝MUI-记一次沉浸式问题]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%B5%85%E5%B0%9DMUI-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B2%89%E6%B5%B8%E5%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[写在前面最近有一个页面需要使用MUI的可左右拖动的顶部选项卡框架，但是这个框架需要自己设定高度，因此使用的JS来动态计算，在计算过程中发现一个问题，使用浏览器测试时（真机，浏览器同苹果6测试），通过图1可以看出，计算出的框架高度应该是100px，但是在真机运行时，控制台打印出来的高度却是，120px，ps：(因为有底部导航栏51px，采用的原生方案，因此压缩了webview页面高度，所以看到的页面高度为616px。) 分析过程进一步分析，计算出图3部分的高度： 通过图4，图5,可看到打印出来的高度值： 通过上图可以看出，这部分的元素没有影响我们的高度获取，那么继续进一步排查，再往上走就只有header标签（图6），但是这部分高度我们是给的固定值44px，不管怎么说，打印出来试试： 通过图7 图8可以发现，真机运行和浏览器运行居然不一样！ 此时，恍然大悟! 结论因为设置了沉浸式状态栏，所以通过获取状态栏高度，自动调整了header标签的高度（ps：给了一个paddingtop；padding在使用offsetHeight计算高度时，会计算进去）。因此我们多出来16px的高度，导致页面出现纵向滚动条。进一步猜测：设置了沉浸式后，状态栏就像是absolute属性一样，浮动在上方。因此，小伙伴们一定要注意这个问题！（ps：查了好久，一直以为是offsetTop属性不会获取padding的值，顺带跑去复习了一遍offset的用法。。。结果查出来是状态栏原因。）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--详解im-chat源码]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E8%AF%A6%E8%A7%A3im-chat%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[写在前面因最近项目需要制作一个聊天界面，对比后感觉MUI源码内的im-chat.html文件对各种情况的处理比较的全面，因此，将整个页面的逻辑从头到尾理了一遍，希望有需求的小伙伴可以少走弯路，通过这个模板，可以根据我们自己需要的功能进行定制，如果不是很清楚（用词不当）的地方，还请小伙伴们提出来，做相关修改，谢谢！ps：理这种逻辑性的东西需要耐心，所以希望小伙伴能够静下心来慢慢理，任何代码都是根据需求实现。所以，可以结合实际操作来看相关模块。最后，求一波关注，哈哈！ 相关引用这个聊天框架基于MUI开发，正常引入相关文件后，还需引入如下文件： 图片预览的mui.imageviewer.css样式文件， 处理图片浏览的mui.imageViewer.js文件， 模板渲染的arttmpl.js文件；代码详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448&lt;body contextmenu=&quot;return false;&quot;&gt; &lt;header class=&quot;mui-bar mui-bar-nav&quot;&gt; &lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; &lt;h1 class=&quot;mui-title&quot;&gt;chat (聊天窗口)&lt;/h1&gt; &lt;/header&gt; &lt;pre id=&apos;h&apos;&gt;&lt;/pre&gt; &lt;script id=&apos;msg-template&apos; type=&quot;text/template&quot;&gt; &lt;% for(var i in record)&#123; var item=record[i]; %&gt; &lt;div class=&quot;msg-item &lt;%= (item.sender==&apos;self&apos;?&apos; msg-item-self&apos;:&apos;&apos;) %&gt;&quot; msg-type=&apos;&lt;%=(item.type)%&gt;&apos; msg-content=&apos;&lt;%=(item.content)%&gt;&apos;&gt; &lt;% if(item.sender==&apos;self&apos; ) &#123; %&gt; &lt;i class=&quot;msg-user mui-icon mui-icon-person&quot;&gt;&lt;/i&gt; &lt;% &#125; else &#123; %&gt; &lt;img class=&quot;msg-user-img&quot; src=&quot;../images/logo.png&quot; alt=&quot;&quot; /&gt; &lt;% &#125; %&gt; &lt;div class=&quot;msg-content&quot;&gt; &lt;div class=&quot;msg-content-inner&quot;&gt; &lt;% if(item.type==&apos;text&apos; ) &#123; %&gt; &lt;%=( item.content|| &apos;&amp;nbsp;&amp;nbsp;&apos;) %&gt; &lt;% &#125; else if(item.type==&apos;image&apos; ) &#123; %&gt; &lt;img class=&quot;msg-content-image&quot; src=&quot;&lt;%=(item.content)%&gt;&quot; style=&quot;max-width: 100px;&quot; /&gt; &lt;% &#125; else if(item.type==&apos;sound&apos; ) &#123; %&gt; &lt;span class=&quot;mui-icon mui-icon-mic&quot; style=&quot;font-size: 18px;font-weight: bold;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;play-state&quot;&gt;点击播放&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;msg-content-arrow&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mui-item-clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/script&gt; &lt;div class=&quot;mui-content&quot;&gt; &lt;div id=&apos;msg-list&apos;&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer&gt; &lt;div class=&quot;footer-left&quot;&gt; &lt;i id=&apos;msg-image&apos; class=&quot;mui-icon mui-icon-camera&quot; style=&quot;font-size: 28px;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;footer-center&quot;&gt; &lt;textarea id=&apos;msg-text&apos; type=&quot;text&quot; class=&apos;input-text&apos;&gt;&lt;/textarea&gt; &lt;button id=&apos;msg-sound&apos; type=&quot;button&quot; class=&apos;input-sound&apos; style=&quot;display: none;&quot;&gt;按住说话&lt;/button&gt; &lt;/div&gt; &lt;label for=&quot;&quot; class=&quot;footer-right&quot;&gt; &lt;i id=&apos;msg-type&apos; class=&quot;mui-icon mui-icon-mic&quot;&gt;&lt;/i&gt; &lt;/label&gt; &lt;/footer&gt; &lt;div id=&apos;sound-alert&apos; class=&quot;rprogress&quot;&gt; &lt;div class=&quot;rschedule&quot;&gt;&lt;/div&gt; &lt;div class=&quot;r-sigh&quot;&gt;!&lt;/div&gt; &lt;div id=&quot;audio_tips&quot; class=&quot;rsalert&quot;&gt;手指上滑，取消发送&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/mui.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/mui.imageViewer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/arttmpl.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; (function($, doc) &#123; var MIN_SOUND_TIME = 800; $.init(&#123; gestureConfig: &#123; tap: true, //默认为true doubletap: true, //默认为false longtap: true, //默认为false swipe: true, //默认为true drag: true, //默认为true hold: true, //默认为false，不监听 release: true //默认为false，不监听 &#125; &#125;); template.config(&apos;escape&apos;, false); //$.plusReady=function(fn)&#123;fn();&#125;; $.plusReady(function() &#123; plus.webview.currentWebview().setStyle(&#123; softinputMode: &quot;adjustResize&quot; &#125;); //强制弹出键盘 var showKeyboard = function() &#123; if ($.os.ios) &#123; var webView = plus.webview.currentWebview().nativeInstanceObject(); webView.plusCallMethod(&#123; &quot;setKeyboardDisplayRequiresUserAction&quot;: false &#125;); &#125; else &#123; var Context = plus.android.importClass(&quot;android.content.Context&quot;); var InputMethodManager = plus.android.importClass(&quot;android.view.inputmethod.InputMethodManager&quot;); var main = plus.android.runtimeMainActivity(); var imm = main.getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED); //var view = ((ViewGroup)main.findViewById(android.R.id.content)).getChildAt(0); imm.showSoftInput(main.getWindow().getDecorView(), InputMethodManager.SHOW_IMPLICIT); //alert(&quot;ll&quot;); &#125; &#125;; var record = [&#123; sender: &apos;zs&apos;, type: &apos;text&apos;, content: &apos;Hi，我是 MUI 小管家！&apos; &#125;]; var ui = &#123; body: doc.querySelector(&apos;body&apos;), footer: doc.querySelector(&apos;footer&apos;), footerRight: doc.querySelector(&apos;.footer-right&apos;), footerLeft: doc.querySelector(&apos;.footer-left&apos;), btnMsgType: doc.querySelector(&apos;#msg-type&apos;), boxMsgText: doc.querySelector(&apos;#msg-text&apos;), boxMsgSound: doc.querySelector(&apos;#msg-sound&apos;), btnMsgImage: doc.querySelector(&apos;#msg-image&apos;), areaMsgList: doc.querySelector(&apos;#msg-list&apos;), boxSoundAlert: doc.querySelector(&apos;#sound-alert&apos;), h: doc.querySelector(&apos;#h&apos;), content: doc.querySelector(&apos;.mui-content&apos;) &#125;; //将文本框宽度赋值给h ui.h.style.width = ui.boxMsgText.offsetWidth + &apos;px&apos;; //alert(ui.boxMsgText.offsetWidth ); //让文本框居中 var footerPadding = ui.footer.offsetHeight - ui.boxMsgText.offsetHeight; //语音输入相关操作 var msgItemTap = function(msgItem, event) &#123; var msgType = msgItem.getAttribute(&apos;msg-type&apos;); var msgContent = msgItem.getAttribute(&apos;msg-content&apos;) if (msgType == &apos;sound&apos;) &#123; player = plus.audio.createPlayer(msgContent); var playState = msgItem.querySelector(&apos;.play-state&apos;); playState.innerText = &apos;正在播放...&apos;; player.play(function() &#123; playState.innerText = &apos;点击播放&apos;; &#125;, function(e) &#123; playState.innerText = &apos;点击播放&apos;; &#125;); &#125; &#125;; //图片预览组件 var imageViewer = new $.ImageViewer(&apos;.msg-content-image&apos;, &#123; dbl: false &#125;); //绑定消息节点 var bindMsgList = function() &#123; //绑定数据: /*tp.bind(&#123; template: &apos;msg-template&apos;, element: &apos;msg-list&apos;, model: record &#125;);*/ //将数据绑定到界面上 ui.areaMsgList.innerHTML = template(&apos;msg-template&apos;, &#123; &quot;record&quot;: record &#125;); //拿到所有的聊天节点 var msgItems = ui.areaMsgList.querySelectorAll(&apos;.msg-item&apos;); //因为document.querySelectorAll()返回的并不是我们想当然的数组，而是NodeList，对NodeList，它里面没有.forEach方法，我们使用了这样的方法进行循环： //通过call将this绑定到msgItems（以[]下标的方式去遍历msgItems） [].forEach.call(msgItems, function(item, index) &#123; item.addEventListener(&apos;tap&apos;, function(event) &#123; //处理语音消息播放 msgItemTap(item, event); &#125;, false); &#125;); //查找所有符合条件的图片 imageViewer.findAllImage(); //聊天界面的高度修改 ui.areaMsgList.scrollTop = ui.areaMsgList.scrollHeight + ui.areaMsgList.offsetHeight; &#125;; bindMsgList(); //平滑高度过渡 window.addEventListener(&apos;resize&apos;, function() &#123; ui.areaMsgList.scrollTop = ui.areaMsgList.scrollHeight + ui.areaMsgList.offsetHeight; &#125;, false); //发送对象声明 var send = function(msg) &#123; //将消息内容体push进record record.push(msg); //绑定消息节点 bindMsgList(); toRobot(msg.content); &#125;; var toRobot = function(info) &#123; var apiUrl = &apos;http://www.tuling123.com/openapi/api&apos;; $.getJSON(apiUrl, &#123; &quot;key&quot;: &apos;acfbca724ea1b5db96d2eef88ce677dc&apos;, &quot;info&quot;: info, &quot;userid&quot;: plus.device.uuid &#125;, function(data) &#123; //alert(JSON.stringify(data)); record.push(&#123; sender: &apos;zs&apos;, type: &apos;text&apos;, content: data.text &#125;); bindMsgList(); &#125;); &#125;; //让输入框获取焦点 function msgTextFocus() &#123; ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); &#125; //解决长按“发送”按钮，导致键盘关闭的问题； ui.footerRight.addEventListener(&apos;touchstart&apos;, function(event) &#123; if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; msgTextFocus(); event.preventDefault(); &#125; &#125;); //解决长按“发送”按钮，导致键盘关闭的问题； ui.footerRight.addEventListener(&apos;touchmove&apos;, function(event) &#123; if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; msgTextFocus(); event.preventDefault(); &#125; &#125;); // ui.footerRight.addEventListener(&apos;touchcancel&apos;, function(event) &#123; // if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; // msgTextFocus(); // event.preventDefault(); // &#125; // &#125;); // ui.footerRight.addEventListener(&apos;touchend&apos;, function(event) &#123; // if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; // msgTextFocus(); // event.preventDefault(); // &#125; // &#125;); //长按离开屏幕时触发 ui.footerRight.addEventListener(&apos;release&apos;, function(event) &#123; //当是文字时 if (ui.btnMsgType.classList.contains(&apos;mui-icon-paperplane&apos;)) &#123; //showKeyboard(); ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); // event.detail.gesture.preventDefault(); send(&#123; sender: &apos;self&apos;, type: &apos;text&apos;, content: ui.boxMsgText.value.replace(new RegExp(&apos;\n&apos;, &apos;gm&apos;), &apos;&lt;br/&gt;&apos;) &#125;); ui.boxMsgText.value = &apos;&apos;; $.trigger(ui.boxMsgText, &apos;input&apos;, null); &#125; //当是语音时 else if (ui.btnMsgType.classList.contains(&apos;mui-icon-mic&apos;)) &#123; ui.btnMsgType.classList.add(&apos;mui-icon-compose&apos;); ui.btnMsgType.classList.remove(&apos;mui-icon-mic&apos;); ui.boxMsgText.style.display = &apos;none&apos;; ui.boxMsgSound.style.display = &apos;block&apos;; ui.boxMsgText.blur(); document.body.focus(); &#125; //当是文本状态时 else if (ui.btnMsgType.classList.contains(&apos;mui-icon-compose&apos;)) &#123; ui.btnMsgType.classList.add(&apos;mui-icon-mic&apos;); ui.btnMsgType.classList.remove(&apos;mui-icon-compose&apos;); ui.boxMsgSound.style.display = &apos;none&apos;; ui.boxMsgText.style.display = &apos;block&apos;; //-- //showKeyboard(); ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 150); &#125; &#125;, false); //点击左边按钮时 ui.footerLeft.addEventListener(&apos;tap&apos;, function(event) &#123; var btnArray = [&#123; title: &quot;拍照&quot; &#125;, &#123; title: &quot;从相册选择&quot; &#125;]; plus.nativeUI.actionSheet(&#123; title: &quot;选择照片&quot;, cancel: &quot;取消&quot;, buttons: btnArray &#125;, function(e) &#123; var index = e.index; switch (index) &#123; case 0: break; case 1: var cmr = plus.camera.getCamera(); cmr.captureImage(function(path) &#123; send(&#123; sender: &apos;self&apos;, type: &apos;image&apos;, content: &quot;file://&quot; + plus.io.convertLocalFileSystemURL(path) &#125;); &#125;, function(err) &#123;&#125;); break; case 2: plus.gallery.pick(function(path) &#123; send(&#123; sender: &apos;self&apos;, type: &apos;image&apos;, content: path &#125;); &#125;, function(err) &#123;&#125;, null); break; &#125; &#125;); &#125;, false); //控制按住语音时的显示与隐藏 var setSoundAlertVisable=function(show)&#123; if(show)&#123; ui.boxSoundAlert.style.display = &apos;block&apos;; ui.boxSoundAlert.style.opacity = 1; &#125;else&#123; ui.boxSoundAlert.style.opacity = 0; //fadeOut 完成再真正隐藏 setTimeout(function()&#123; ui.boxSoundAlert.style.display = &apos;none&apos;; &#125;,200); &#125; &#125;; var recordCancel = false; var recorder = null; var audio_tips = document.getElementById(&quot;audio_tips&quot;); var startTimestamp = null; var stopTimestamp = null; var stopTimer = null; //按住说话时候触发 ui.boxMsgSound.addEventListener(&apos;hold&apos;, function(event) &#123; recordCancel = false; //如果有结束时间，清除定时器 if(stopTimer)clearTimeout(stopTimer); //修改显示文字 audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; //移除rprogress-sigh ui.boxSoundAlert.classList.remove(&apos;rprogress-sigh&apos;); //显示样式 setSoundAlertVisable(true); //获取录音对象 5+模块 recorder = plus.audio.getRecorder(); if (recorder == null) &#123; plus.nativeUI.toast(&quot;不能获取录音对象&quot;); return; &#125; //记录当前录音时间 startTimestamp = (new Date()).getTime(); //保存录音http://www.html5plus.org/doc/zh_cn/audio.html#plus.audio.RecordOption recorder.record(&#123; filename: &quot;_doc/audio/&quot; &#125;, function(path) &#123; if (recordCancel) return; send(&#123; sender: &apos;self&apos;, type: &apos;sound&apos;, content: path &#125;); &#125;, function(e) &#123; plus.nativeUI.toast(&quot;录音时出现异常: &quot; + e.message); &#125;); &#125;, false); //监听drag（拖动中）事件 上滑;下滑事件 ui.body.addEventListener(&apos;drag&apos;, function(event) &#123; //console.log(&apos;drag&apos;); if (Math.abs(event.detail.deltaY) &gt; 50) &#123; //此时没有录音操作执行 检查recordCancel状态 if (!recordCancel) &#123; recordCancel = true; if (!audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.add(&quot;cancel&quot;); &#125; audio_tips.innerHTML = &quot;松开手指，取消发送&quot;; &#125; &#125; else &#123; if (recordCancel) &#123; recordCancel = false; if (audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.remove(&quot;cancel&quot;); &#125; audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; &#125; &#125; &#125;, false); //长按离开录音节点时执行 ui.boxMsgSound.addEventListener(&apos;release&apos;, function(event) &#123; //console.log(&apos;release&apos;); //初始化 if (audio_tips.classList.contains(&quot;cancel&quot;)) &#123; audio_tips.classList.remove(&quot;cancel&quot;); audio_tips.innerHTML = &quot;手指上划，取消发送&quot;; &#125; //判断录音是否小于800毫秒，若小于，则废弃 stopTimestamp = (new Date()).getTime(); if (stopTimestamp - startTimestamp &lt; MIN_SOUND_TIME) &#123; audio_tips.innerHTML = &quot;录音时间太短&quot;; ui.boxSoundAlert.classList.add(&apos;rprogress-sigh&apos;); recordCancel = true; stopTimer=setTimeout(function()&#123; setSoundAlertVisable(false); &#125;,800); &#125;else&#123; setSoundAlertVisable(false); &#125; //停止录音模块 recorder.stop(); &#125;, false); //阻止浏览器默认的事件冒泡 ui.boxMsgSound.addEventListener(&quot;touchstart&quot;, function(e) &#123; //console.log(&quot;start....&quot;); e.preventDefault(); &#125;); //监听用户输入时触发 ui.boxMsgText.addEventListener(&apos;input&apos;, function(event) &#123; //当输入为空时去掉发送文字，当不为空时，显示发送文字 ui.btnMsgType.classList[ui.boxMsgText.value == &apos;&apos; ? &apos;remove&apos; : &apos;add&apos;](&apos;mui-icon-paperplane&apos;); //当用户输入值不为空时，设置自定义属性for 赋值msg-text ui.btnMsgType.setAttribute(&quot;for&quot;, ui.boxMsgText.value == &apos;&apos; ? &apos;&apos; : &apos;msg-text&apos;); //替换与正则表达式相匹配的值(转义) ui.h.innerText = ui.boxMsgText.value.replace(new RegExp(&apos;\n&apos;, &apos;gm&apos;), &apos;\n-&apos;) || &apos;-&apos;; //动态调整输入框高度 ui.footer.style.height = (ui.h.offsetHeight + footerPadding) + &apos;px&apos;; //调整显示信息高度 ui.content.style.paddingBottom = ui.footer.style.height; &#125;); var focus = false; //监听用户点击发送时触发 ui.boxMsgText.addEventListener(&apos;tap&apos;, function(event) &#123; //得到焦点 ui.boxMsgText.focus(); setTimeout(function() &#123; ui.boxMsgText.focus(); &#125;, 0); focus = true; setTimeout(function () &#123; focus = false; &#125;,1000); //阻止iOS2.0中的手势事件：gesture事件 event.detail.gesture.preventDefault(); &#125;, false); //点击消息列表，关闭键盘 ui.areaMsgList.addEventListener(&apos;click&apos;,function (event) &#123; if(!focus)&#123; ui.boxMsgText.blur(); &#125; &#125;) &#125;); &#125;(mui, document)); &lt;/script&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探prototype]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2prototype%2F</url>
    <content type="text"><![CDATA[// 构造函数/基类function Human(name){ this.name = name;}//将基类的方法保存在构造函数的prototype属性中//便于子类的继承Human.prototype.say=function(){ console.log(‘say’);} //道格拉斯的object方法(等同于object.create方法)function object(o){ var F = function(){}; F.prototype = o; return new F();} //子类构造器function Man(name,age){ //调用父类的构造函数 Human.call(this,name); //自己属性的age this.age = age;} //继承父类的方法 constructor 属性返回对创建此对象的数组函数的引用。Man.prototype = object(Human,prototype);Man.prototype.constructor = Man; //实例化子类var man = new Man(“Lee”, 22);console.log(man);//调用父类的say方法；man.say();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习笔记(一)]]></title>
    <url>%2F2017%2F10%2F19%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[学习笔记关于node.js1.node.js属于单线程，单进程应用程序，每个API都是异步进行，并作为独立线程运行。2.Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。3.Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.4.在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 理解：在主线程接收到请求等操作，便分出一个进程单独处理，而主进程依然按照以前的状态运行，这样，只需要一个单进程的单线程就处理高并发。（难道线程或进程开多了不会造成卡顿吗？），而事件驱动模型，类似于主进程在那里观察整个运作流程，而有进程处理完相关操作后，返回给主进程，然后主进程按照编程者所预设的流程执行下一步？ 关于Node.js EventEmitter1.Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。2.Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 1.EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 2.EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 理解：许多对象分发的事件都是EventEmitter的实例，也就是说，假如我们需要监听我们的事件是否执行，执行完毕，执行错误等，都可以通过监听这个EventEmitter 类来实现。不知是否用于添加自定义函数，可以监听函数的各种变化？暂不知道有什么用… 关于Node.js Buffer(缓冲区) Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。2.Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。理解：用来暂时存储流，元信息等？ 关于Node.js Stream(流)1.Node.js，Stream 有四种流类型： Readable - 可读操作。 ritable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。2.所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 理解：将文件等转化为二进制后慢慢写入或者读出来？管道流：实现大文件复制，文件不是一次发送过去，而像是流水一样慢慢流入，并且在流完后组合成大文件。 关于Node.js模块系统1.Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。2.模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 理解：模块系统，使不同模块，不同文件之间，实现信息共享，相互引用？ ！ 关于Node.js 函数1.在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。2.我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) { someFunction(value); } execute(function(word){ console.log(word) }, “Hello”); 理解：函数与在浏览器端使用相同，匿名函数，函数传递？ 关于Node.js 路由1.我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。2.我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 理解：将请求分发，重定位到服务器上不同的处理请求的函数中去？ 关于Node.js 全局对象1.JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。2.在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。3.在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。4.global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量；全局对象的属性；隐式定义的变量（未定义直接赋值的变量）。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。5.filename: 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。6.dirname: 表示当前执行脚本所在的目录。7.setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。8.clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。9.console 方法1 console.log([data][, …])向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。2 console.info([data][, …])该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。3 console.error([data][, …])输出错误消息的。控制台在出现错误时会显示是红色的叉子。4 console.warn([data][, …])输出警告消息。控制台出现有黄色的惊叹号。5 console.dir(obj[, options])用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。6 console.time(label)输出时间，表示计时开始。7 console.timeEnd(label)结束时间，表示计时结束。8 console.trace(message[, …])当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。9 console.assert(value[, message][, …])用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 10.console.trace()：向标准错误流输出当前的调用栈。 运行结果为：Trace:at Object. (/home/byvoid/consoletrace.js:1:71)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 11.process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。 1 exit当进程准备退出时触发。2 beforeExit当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。3 uncaughtException当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。4 Signal 事件当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 退出状态码如下所示： 1 Uncaught Fatal Exception有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。2 Unused保留3 Internal JavaScript Parse ErrorJavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。4 Internal JavaScript Evaluation FailureJavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。5 Fatal ErrorV8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR6 Non-function Internal Exception Handler未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。7 Internal Exception Handler Run-Time Failure未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。8 Unused保留9 Invalid Argument可能是给了未知的参数，或者给的参数没有值。10 Internal JavaScript Run-Time FailureJavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。12 Invalid Debug Argument设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。128 Signal Exits如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。 Process 提供了很多有用的属性，便于我们更好的控制系统的交互： 1 stdout标准输出流。2 stderr标准错误流。3 stdin标准输入流。4 argvargv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。5 execPath返回执行当前脚本的 Node 二进制文件的绝对路径。6 execArgv返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。7 env返回一个对象，成员为当前 shell 的环境变量8 exitCode进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。9 versionNode 的版本，比如v0.10.18。10 versions一个属性，包含了 node 的版本和依赖.11 config一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。12 pid当前进程的进程号。13 title进程名，默认值为”node”，可以自定义该值。14 arch当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。15 platform运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’16 mainModulerequire.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 Process 提供了很多有用的方法，便于我们更好的控制系统的交互： 1 abort()这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。2 chdir(directory)改变当前工作进程的目录，如果操作失败抛出异常。3 cwd()返回当前进程的工作目录4 exit([code])使用指定的 code 结束进程。如果忽略，将会使用 code 0。5 getgid()获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。6 setgid(id)设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。7 getuid()获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。8 setuid(id)设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。9 getgroups()返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。10 setgroups(groups)设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。11 initgroups(user, extra_group)读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。12 kill(pid[, signal])发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。13 memoryUsage()返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。14 nextTick(callback)一旦当前事件循环结束，调用回到函数。15 umask([mask])设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。16 uptime()返回 Node 已经运行的秒数。17 hrtime()返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 理解：一些常用的控制台输入输出函数，以全局形式存在，目前没有遇到过，也不是很懂具体用法，后期多关注这一模块。 关于Node.js 常用工具1.util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。2.util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。3.JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。 理解： 使用util.inherits只能继承原型链上的函数，并不能继承原型内申明的函数。 4.util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。 5.util.isArray(object)：如果给定的参数 “object” 是一个数组返回true，否则返回false。 6.util.isRegExp(object)： 如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。 7.util.isDate(object)： 如果给定的参数 “object” 是一个日期返回true，否则返回false。 8.util.isError(object)： 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。 理解：和浏览器端的JSON.stringify()等类似？ 关于Node.js 文件系统1.Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。2.Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 理解：用于读写文件内容等操作。 关于Node.js GET/POST请求1.在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。表单提交到服务器一般都使用 GET/POST 请求。 理解：post请求中，不会自动解析body内容，减少恶意POST占用服务器资源。 ###]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝MUI-HBuilder编译器]]></title>
    <url>%2F2017%2F10%2F19%2F%E6%B5%85%E5%B0%9DMUI-HBuilder%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[浅谈HBuilder编译器第一次接触HBuilder是通过老师介绍，这款编译器是中国的公司编写，因此，对于英语不是很好的小伙伴来说是很友好的。当然，这款编译器和MUI框架配套使用可以更加的方便，工欲善其事，必先利其器，所以，今天特地来讲一下HBuilder编译器。附HBuilder下载地址。下面就具体来讲讲HBuildder编译器的简单操作功能吧。ps：关于快捷方式，基本的编译器设置等，因为与我们使用和编写代码关系不大，因此，此处就不展开介绍，只讲与使用MUI相关的知识点。 Hbuilder简单使用HBuilder的组成：由项目管理器，控制台，代码编辑器区，内置浏览器，顶部导航条构成，如图2所示：ps：当我们看过整个内容区域后，讲下今天主要想写的知识点：1.开发视图区别；2.新建一个web项目；3.新建一个APP项目；4.查看MUI源码；5.真机运行；6.自定义调试基座；7.APP的云端打包。1.开发视图简单介绍：平常我们基本上都是用得边改边看模式，因为这个模式可以在代码编辑区编写代码保存后，在右边可以实时查看效果。而WebView调试模式一般用于真机测试时，调试页面（ps：后面详细介绍）。团队同步视图因为很少用，需要小伙伴们自己去开发了哟~~视图切换如图2所示：2.打开文件–&gt;新建–&gt;web项目，此时只需要填写项目名称和保存位置就OK，此时会生成一个项目在项目管理器中，在里面可以看到项目结构。 后记]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI(二)]]></title>
    <url>%2F2017%2F10%2F17%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[初探MUI(二)MUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 学习心得学习完MUI基础理论后，相信很多人都会觉得MUI真的很方便，基本需求都能够的到满足，但其实不然，因为MUI有很多的局限性，以及对某些手机的兼容性问题，导致很多时候会出现莫名其妙的BUG。根据个人观察发现，对于苹果系统更加的友好，而对于安卓系统，因为碎片化太严重，所以应该多找些机型测试。 我遇到过的情况有：1.底部导航栏（html5）：在红米note2，小米3，华为手机上完美使用，但是oppo一款型号底部导航条出现下移情况（注：底部导航条高度通过JS计算，高度写死时不会出现），如果遇到，将底部导航条高度写死。 2.华为手机的虚拟按键，如果按照正常的流式布局下去，当页面内容多于屏幕高度时，底部有fixed定位的元素时，虚拟按键可能会把底部定位的东西遮挡住。(ps:经过测试，华为虚拟按键会缩小屏幕实际高度）解决办法：因为虚拟按键会压缩屏幕高度，而页面底部距离底部定位时，可以将fixed定位的元素挤压上去，将body，html页面高度设置为100%。 3.使用&lt;header&gt;&lt;/header&gt;时，如果页面有&lt;input type=&#39;text /&gt;，此时输入文字会将&lt;header&gt;&lt;/header&gt;挤掉，我的解决办法是：打开软键盘时，挤压webview，减少视口的高度。但是这样做有一个问题，如果页面内容较多，会产生滚动条，给用户的感觉不好。也可以监听软键盘打开事件，动态调整页面。下面仅给出最简单的解决方案：12345mui.plusReady(function () &#123; plus.webview.currentWebview().setStyle(&#123; softinputMode: "adjustResize" &#125;);&#125;); 4.使用原生底部导航条，目前遇到的问题是，真机测试时，在苹果6上完美渲染，测试相关逻辑都成功，但是在红米note2上，有两个ICON渲染不出来，只渲染出来了底部导航栏的高度，具体情况尚在测试中。。。。 学习总结1.在调试MUI项目时，我认为应该先使用安卓手机调试，因为我几次都是在苹果手机上成功调试，但是将源码放到安卓手机上时，出现各种未知的BUG,所以前期测试使用安卓手机，等程序调试完成后，再去苹果手机上测试。 2.因为现在很多人都追求使用原生来写html5，在官方还没发布正式的底部导航条时，就自己按照社区的经验，自己改了一个底部导航条，但是因为打开新的页面时，底部原生导航条不会隐藏，所以没办法，还是只能采用mui提供的底部导航条，所以，对于mui的探索，还是需要自己去多研究，例如：和原生相关的界面渲染，操作原生的内容，调用原生JS等，都需要仔细的研究。所以，我觉得，如果有一定的安卓或者IOS开发经验的人来说比较的容易理解，但是对于一个前端开发人员来说，这一块肯定是学习的重点。 后记]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI%2F</url>
    <content type="text"><![CDATA[初探MUIMUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 浅谈MUI当然，学习一门东西之前肯定需要先了解他，知道这个东西是干什么的。简单的来说，MUI是一个轻量级的HTML5前端框架，用它可以写出轻量级的APP应用，但根据我自己探索出来的区间是:1.安卓手机：4.4以下卡顿比较明显（ps：极有可能是自身代码问题），安卓5.0能够流畅运行；2.苹果手机：测试机使用的苹果6，对于一般应用能够完美运行（ps：苹果5s仅测试过chrome）。（注:以上数据仅为自己测试，测试数据不一定准确。) 学习MUI无论是学习一门语言，还是学习一个框架，必然第一步是看官方文档，唯有熟悉官方文档后，才能谈使用。而我学习的步骤如下：1.全览MUI文档，对MUI框架有一个简单的认识，知道这个框架大概有哪些东西，一般用于什么情况，此为第一次浏览。2.熟悉文档后，打开Hbuilder，文件-&gt;新建-&gt;移动APP，在弹出框中选中Hello mui，并输入应用名称，此时会有一个项目出现在左侧栏，里面便是整个MUI框架的源码。 （注：为什么这步写的这么详细呢，因为我发现很多小伙伴用了几个月时间的Hbuilder居然不知道这个编译器还可以写手机APP，Hbuilder最初不是和MUI配套发布的吗？表示不理解~）3.拿到源码后，先看一遍整个demo，很多文档上面提到的东西，在源码里面都有体现，当然，我学到这一步时，脑袋里也只有一点最初的概念，这时，我觉得就没必要再去深究了。因为代码这种东西必须要多敲，所以，自己新建一个项目，模仿一个APP来写页面。那么，重点来了，各种复制粘贴MUI源码里面的东西来修改吧，建议调试使用（chrome浏览器）。4.或许有人不理解为什么要模仿，但是我感觉模仿是最简单，也是最节省精力的一种方法，因为不用考虑布局本身，只需要把框架内的东西复制粘贴出来，似拼图一般，搭建一个属于自己的第一个APP界面，当然，在这个过程中肯定会遇到很多的问题，我的建议是自己去网上找资料并且看代码。网上资料的话可以去MUI的问答社区，感觉这个社区已经足够解决大部分问题了，如果还有不能解决的问题，那么我感觉大部分原因在自身（1.忘记引入相关文件 2.以往设置相关模块的JS代码），这个时候就需要更多的耐心查看代码相关逻辑了。 后记只要反复练习上面的第四点，我相信对MUI框架和HTML5在手机端的布局就会有一个明确的认识，这个时候再去浏览一遍官方文档和demo肯定会有新的收获。毕竟身为程序员，逃不掉的始终是敲代码，唯有多练习，才能更加熟悉，唯有动手了，才能知道自己哪些知识点还不足，从而更加针对性的去补足。上面的内容，虽然对代码只字未提，但是我想无论是编程语言还是框架等都只是一个工具，在学习时，更多的是找到自己学习的节奏和方法，编程时，更多的是思路和想法。以上内容仅为自己的学习过程，欢迎大家取其精华，丢其糟粕，找到自己的学习状态。若对以上内容有不同简介或看法，欢迎一起探讨。企鹅号：1041415167 邮箱地址：zth1041415167@outlook.com 附部分学习资料地址： forked from dcloudio DCloud开源项目集锦 问答社区 forked from 小青年 github MUI框架视频教程地址 （ps：第一次写这个，写的不好还请多多见谅！终于领悟一个道理，知道容易，想要很好的说出来真的好难^-^ ^-^ 以上内容可能会不定期修改更新，下一篇日记准备列出关于MUI在学习MUI时遇到的各种坑，希望新学的小伙伴不要再去踩，也希望有兴趣的小伙伴多多关注！）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
</search>
