<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js学习笔记(一)]]></title>
    <url>%2F2017%2F10%2F19%2Fnode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[学习笔记关于node.js1.node.js属于单线程，单进程应用程序，每个API都是异步进行，并作为独立线程运行。2.Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。3.Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.4.在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 理解：在主线程接收到请求等操作，便分出一个进程单独处理，而主进程依然按照以前的状态运行，这样，只需要一个单进程的单线程就处理高并发。（难道线程或进程开多了不会造成卡顿吗？），而事件驱动模型，类似于主进程在那里观察整个运作流程，而有进程处理完相关操作后，返回给主进程，然后主进程按照编程者所预设的流程执行下一步？ 关于Node.js EventEmitter1.Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。2.Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 1.EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 2.EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 理解：许多对象分发的事件都是EventEmitter的实例，也就是说，假如我们需要监听我们的事件是否执行，执行完毕，执行错误等，都可以通过监听这个EventEmitter 类来实现。不知是否用于添加自定义函数，可以监听函数的各种变化？暂不知道有什么用… 关于Node.js Buffer(缓冲区) Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。2.Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。理解：用来暂时存储流，元信息等？ 关于Node.js Stream(流)1.Node.js，Stream 有四种流类型： Readable - 可读操作。 ritable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。2.所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 理解：将文件等转化为二进制后慢慢写入或者读出来？管道流：实现大文件复制，文件不是一次发送过去，而像是流水一样慢慢流入，并且在流完后组合成大文件。 关于Node.js模块系统1.Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。2.模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 理解：模块系统，使不同模块，不同文件之间，实现信息共享，相互引用？ ！ 关于Node.js 函数1.在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。2.我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) { someFunction(value); } execute(function(word){ console.log(word) }, “Hello”); 理解：函数与在浏览器端使用相同，匿名函数，函数传递？ 关于Node.js 路由1.我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。2.我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 理解：将请求分发，重定位到服务器上不同的处理请求的函数中去？ 关于Node.js 全局对象1.JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。2.在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。3.在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。4.global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量；全局对象的属性；隐式定义的变量（未定义直接赋值的变量）。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。5.filename: 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。6.dirname: 表示当前执行脚本所在的目录。7.setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。8.clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。9.console 方法1 console.log([data][, …])向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。2 console.info([data][, …])该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。3 console.error([data][, …])输出错误消息的。控制台在出现错误时会显示是红色的叉子。4 console.warn([data][, …])输出警告消息。控制台出现有黄色的惊叹号。5 console.dir(obj[, options])用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。6 console.time(label)输出时间，表示计时开始。7 console.timeEnd(label)结束时间，表示计时结束。8 console.trace(message[, …])当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。9 console.assert(value[, message][, …])用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 10.console.trace()：向标准错误流输出当前的调用栈。 运行结果为：Trace:at Object. (/home/byvoid/consoletrace.js:1:71)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 11.process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。 1 exit当进程准备退出时触发。2 beforeExit当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。3 uncaughtException当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。4 Signal 事件当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 退出状态码如下所示： 1 Uncaught Fatal Exception有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。2 Unused保留3 Internal JavaScript Parse ErrorJavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。4 Internal JavaScript Evaluation FailureJavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。5 Fatal ErrorV8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR6 Non-function Internal Exception Handler未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。7 Internal Exception Handler Run-Time Failure未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。8 Unused保留9 Invalid Argument可能是给了未知的参数，或者给的参数没有值。10 Internal JavaScript Run-Time FailureJavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。12 Invalid Debug Argument设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。128 Signal Exits如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。 Process 提供了很多有用的属性，便于我们更好的控制系统的交互： 1 stdout标准输出流。2 stderr标准错误流。3 stdin标准输入流。4 argvargv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。5 execPath返回执行当前脚本的 Node 二进制文件的绝对路径。6 execArgv返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。7 env返回一个对象，成员为当前 shell 的环境变量8 exitCode进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。9 versionNode 的版本，比如v0.10.18。10 versions一个属性，包含了 node 的版本和依赖.11 config一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。12 pid当前进程的进程号。13 title进程名，默认值为”node”，可以自定义该值。14 arch当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。15 platform运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’16 mainModulerequire.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 Process 提供了很多有用的方法，便于我们更好的控制系统的交互： 1 abort()这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。2 chdir(directory)改变当前工作进程的目录，如果操作失败抛出异常。3 cwd()返回当前进程的工作目录4 exit([code])使用指定的 code 结束进程。如果忽略，将会使用 code 0。5 getgid()获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。6 setgid(id)设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。7 getuid()获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。8 setuid(id)设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。9 getgroups()返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。10 setgroups(groups)设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。11 initgroups(user, extra_group)读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。12 kill(pid[, signal])发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。13 memoryUsage()返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。14 nextTick(callback)一旦当前事件循环结束，调用回到函数。15 umask([mask])设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。16 uptime()返回 Node 已经运行的秒数。17 hrtime()返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 理解：一些常用的控制台输入输出函数，以全局形式存在，目前没有遇到过，也不是很懂具体用法，后期多关注这一模块。 关于Node.js 常用工具1.util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。2.util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。3.JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。 理解： 使用util.inherits只能继承原型链上的函数，并不能继承原型内申明的函数。 4.util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。 5.util.isArray(object)：如果给定的参数 “object” 是一个数组返回true，否则返回false。 6.util.isRegExp(object)： 如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。 7.util.isDate(object)： 如果给定的参数 “object” 是一个日期返回true，否则返回false。 8.util.isError(object)： 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。 理解：和浏览器端的JSON.stringify()等类似？ 关于Node.js 文件系统1.Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。2.Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 理解：用于读写文件内容等操作。 关于Node.js GET/POST请求1.在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。表单提交到服务器一般都使用 GET/POST 请求。 理解：post请求中，不会自动解析body内容，减少恶意POST占用服务器资源。 ###]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔-2017-10-19]]></title>
    <url>%2F2017%2F10%2F19%2F%E9%9A%8F%E7%AC%94-2017-10-19%2F</url>
    <content type="text"><![CDATA[这学期开学已经接近两个月，一共开设了6门专业课（Linux C++ Mysql PHP ARM单片机 EDA），每周12节课，里面有Linux Mysql PHP都是以前打算好好学习的课程，然而不知为什么，完全不适应老师上课的节奏，有时候不得不问自己一句，是否初心已变？来学校的目的是什么，而在学校学到了什么，现在的我处于大三阶段，然而对于这一点，还是感受到的是迷茫，有时候不禁问自己，来学校这几年到底学到了什么？马上毕业后，以什么去找工作呢，三年的课程，没有一学期是认认真真的上完一科的，其实说实话，现在也有目标，但是却是和课程无关的东西，每学期到期末都会十分的痛苦，纠结自己到底学这些是为了什么？可能是我自己不适应那种上课方式吧，最轻松，最舒适的上课方式莫过于自学，然后不懂得时候能够找到老师问一问，我想这样效率是否会更高呢？从这学期来，就一直有一个焦虑在伴随着自己，那就是担心找工作的事情，其实我自己都不知道自己的担心是不是多余的，并且我还是不能理解，以我这样的水平，能够找到一个好的工作吗？因为在我心中，对于自己学习的东西，感觉才刚刚入门，并且不知道面试的时候需要好多东西，这便是所谓的迷茫吧。也不知为何，现在对于这些事情依然感到压抑。难道是我要的东西太多了吗？还是说我一直走在追逐的路上，其实到现在我都不明白一件事，难道我走的很快吗？这短短的段话，多少个问号，或许这就是目前所想的吧，希望记录下来这种感觉，等几年，十年，再来看看这种感觉，希望讲问号变为句号。如此迷茫的自己，已经不是第一次了吧，希望自己能够做好当下应该做的事情，安安静静的看看书，品品茶，什么都不想。 – end/2017/10/20]]></content>
      <categories>
        <category>mood diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI(二)]]></title>
    <url>%2F2017%2F10%2F17%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[初探MUI(二)MUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 学习心得学习完MUI基础理论后，相信很多人都会觉得MUI真的很方便，基本需求都能够的到满足，但其实不然，因为MUI有很多的局限性，以及对某些手机的兼容性问题，导致很多时候会出现莫名其妙的BUG。根据个人观察发现，对于苹果系统更加的友好，而对于安卓系统，因为碎片化太严重，所以应该多找些机型测试。 我遇到过的情况有：1.底部导航栏（html5）：在红米note2，小米3，华为手机上完美使用，但是oppo一款型号底部导航条出现下移情况（注：底部导航条高度通过JS计算，高度写死时不会出现），如果遇到，将底部导航条高度写死。 2.华为手机的虚拟按键，如果按照正常的流式布局下去，当页面内容多于屏幕高度时，底部有fixed定位的元素时，虚拟按键可能会把底部定位的东西遮挡住。(ps:经过测试，华为虚拟按键会缩小屏幕实际高度）解决办法：因为虚拟按键会压缩屏幕高度，而页面底部距离底部定位时，可以将fixed定位的元素挤压上去，将body，html页面高度设置为100%。 3.使用&lt;header&gt;&lt;/header&gt;时，如果页面有&lt;input type=&#39;text /&gt;，此时输入文字会将&lt;header&gt;&lt;/header&gt;挤掉，我的解决办法是：打开软键盘时，挤压webview，减少视口的高度。但是这样做有一个问题，如果页面内容较多，会产生滚动条，给用户的感觉不好。也可以监听软键盘打开事件，动态调整页面。下面仅给出最简单的解决方案：12345mui.plusReady(function () &#123; plus.webview.currentWebview().setStyle(&#123; softinputMode: "adjustResize" &#125;);&#125;); 4.使用原生底部导航条，目前遇到的问题是，真机测试时，在苹果6上完美渲染，测试相关逻辑都成功，但是在红米note2上，有两个ICON渲染不出来，只渲染出来了底部导航栏的高度，具体情况尚在测试中。。。。 学习总结1.在调试MUI项目时，我认为应该先使用安卓手机调试，因为我几次都是在苹果手机上成功调试，但是将源码放到安卓手机上时，出现各种未知的BUG,所以前期测试使用安卓手机，等程序调试完成后，再去苹果手机上测试。 2.因为现在很多人都追求使用原生来写html5，在官方还没发布正式的底部导航条时，就自己按照社区的经验，自己改了一个底部导航条，但是因为打开新的页面时，底部原生导航条不会隐藏，所以没办法，还是只能采用mui提供的底部导航条，所以，对于mui的探索，还是需要自己去多研究，例如：和原生相关的界面渲染，操作原生的内容，调用原生JS等，都需要仔细的研究。所以，我觉得，如果有一定的安卓或者IOS开发经验的人来说比较的容易理解，但是对于一个前端开发人员来说，这一块肯定是学习的重点。 后记]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记之--初探MUI]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%88%9D%E6%8E%A2MUI%2F</url>
    <content type="text"><![CDATA[初探MUIMUI是一个HTML5前端框架，主要用于手机APP开发。附MUI官方文档。以下内容均围绕MUI进行讨论，欢迎大家骚扰^^ 浅谈MUI当然，学习一门东西之前肯定需要先了解他，知道这个东西是干什么的。简单的来说，MUI是一个轻量级的HTML5前端框架，用它可以写出轻量级的APP应用，但根据我自己探索出来的区间是:1.安卓手机：4.4以下卡顿比较明显（ps：极有可能是自身代码问题），安卓5.0能够流畅运行；2.苹果手机：测试机使用的苹果6，对于一般应用能够完美运行（ps：苹果5s仅测试过chrome）。（注:以上数据仅为自己测试，测试数据不一定准确。) 学习MUI无论是学习一门语言，还是学习一个框架，必然第一步是看官方文档，唯有熟悉官方文档后，才能谈使用。而我学习的步骤如下：1.全览MUI文档，对MUI框架有一个简单的认识，知道这个框架大概有哪些东西，一般用于什么情况，此为第一次浏览。2.熟悉文档后，打开Hbuilder，文件-&gt;新建-&gt;移动APP，在弹出框中选中Hello mui，并输入应用名称，此时会有一个项目出现在左侧栏，里面便是整个MUI框架的源码。 （注：为什么这步写的这么详细呢，因为我发现很多小伙伴用了几个月时间的Hbuilder居然不知道这个编译器还可以写手机APP，Hbuilder最初不是和MUI配套发布的吗？表示不理解~）3.拿到源码后，先看一遍整个demo，很多文档上面提到的东西，在源码里面都有体现，当然，我学到这一步时，脑袋里也只有一点最初的概念，这时，我觉得就没必要再去深究了。因为代码这种东西必须要多敲，所以，自己新建一个项目，模仿一个APP来写页面。那么，重点来了，各种复制粘贴MUI源码里面的东西来修改吧，建议调试使用（chrome浏览器）。4.或许有人不理解为什么要模仿，但是我感觉模仿是最简单，也是最节省精力的一种方法，因为不用考虑布局本身，只需要把框架内的东西复制粘贴出来，似拼图一般，搭建一个属于自己的第一个APP界面，当然，在这个过程中肯定会遇到很多的问题，我的建议是自己去网上找资料并且看代码。网上资料的话可以去MUI的问答社区，感觉这个社区已经足够解决大部分问题了，如果还有不能解决的问题，那么我感觉大部分原因在自身（1.忘记引入相关文件 2.以往设置相关模块的JS代码），这个时候就需要更多的耐心查看代码相关逻辑了。 后记只要反复练习上面的第四点，我相信对MUI框架和HTML5在手机端的布局就会有一个明确的认识，这个时候再去浏览一遍官方文档和demo肯定会有新的收获。毕竟身为程序员，逃不掉的始终是敲代码，唯有多练习，才能更加熟悉，唯有动手了，才能知道自己哪些知识点还不足，从而更加针对性的去补足。上面的内容，虽然对代码只字未提，但是我想无论是编程语言还是框架等都只是一个工具，在学习时，更多的是找到自己学习的节奏和方法，编程时，更多的是思路和想法。以上内容仅为自己的学习过程，欢迎大家取其精华，丢其糟粕，找到自己的学习状态。若对以上内容有不同简介或看法，欢迎一起探讨。企鹅号：1041415167 邮箱地址：zth1041415167@outlook.com 附部分学习资料地址： forked from dcloudio DCloud开源项目集锦 问答社区 forked from 小青年 github MUI框架视频教程地址 （ps：第一次写这个，写的不好还请多多见谅！终于领悟一个道理，知道容易，想要很好的说出来真的好难^-^ ^-^ 以上内容可能会不定期修改更新，下一篇日记准备列出关于MUI在学习MUI时遇到的各种坑，希望新学的小伙伴不要再去踩，也希望有兴趣的小伙伴多多关注！）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>MUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
